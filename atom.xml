<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-23T17:15:44.938Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-主从与哨兵架构</title>
    <link href="http://example.com/posts/redis-family/4/"/>
    <id>http://example.com/posts/redis-family/4/</id>
    <published>2023-11-22T16:00:00.000Z</published>
    <updated>2023-11-23T17:15:44.938Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Jedis使用&quot;&gt;&lt;a href=&quot;#Jedis使用&quot; class=&quot;headerlink&quot; title=&quot;Jedis使用&quot;&gt;&lt;/a&gt;Jedis使用&lt;/h2&gt;&lt;h4 id=&quot;Jedis连接代码示例：&quot;&gt;&lt;a href=&quot;#Jedis连接代码示例：&quot; class=&quot;headerlink&quot; title=&quot;Jedis连接代码示例：&quot;&gt;&lt;/a&gt;Jedis连接代码示例：&lt;/h4&gt;&lt;p&gt;1、引入依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、访问代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class JedisSingleTest
{
    public static void main(String[] args)
    {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(20);
        jedisPoolConfig.setMaxIdle(10);
        jedisPoolConfig.setMinIdle(5);
        
        // timeout，这里既是连接超时又是读写超时，从Jedis 2.8开始有区分connectionTimeout和soTimeout的构造函数
        JedisPool jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.0.4&quot;, 6379, 3000, null);
        
        Jedis jedis = jedisPool.getResource();
        System.out.println(jedis.set(&quot;single&quot;, &quot;gc&quot;));  // OK
        System.out.println(jedis.get(&quot;single&quot;));		// gc
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：如果是购买的云服务器，需要在安全组添加端口规则&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-持久化</title>
    <link href="http://example.com/posts/redis-family/3/"/>
    <id>http://example.com/posts/redis-family/3/</id>
    <published>2023-11-21T16:00:00.000Z</published>
    <updated>2023-11-22T15:11:58.548Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;h3 id=&quot;RDB快照（snapshot）&quot;&gt;&lt;a href=&quot;#RDB快照（snapshot）&quot; class=&quot;headerlink&quot; title=&quot;RDB快照（snapshot）&quot;&gt;&lt;/a&gt;RDB快照（snapshot）&lt;/h3&gt;&lt;p&gt;Redis 的内存数据库快照默认保存在 &lt;code&gt;dump.rdb&lt;/code&gt; 二进制文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis.conf&lt;/code&gt;配置文件描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;# Save the DB to disk.
#
# save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; [&amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; ...]
#
# Redis will save the DB if the given number of seconds elapsed and it
# surpassed the given number of write operations against the DB.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save &quot;&quot;
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 change was performed
#   * After 300 seconds (5 minutes) if at least 100 changes were performed
#   * After 60 seconds if at least 10000 changes were performed
#
# You can set these explicitly by uncommenting the following line.
#
# save 3600 1 300 100 60 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成RDB快照命令：&lt;strong&gt;save&lt;/strong&gt;或&lt;strong&gt;bgsave&lt;/strong&gt;（redis客户端执行命令，每次执行生成新的rdb文件，覆盖原有的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bgsave的写时复制(COW)机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 &lt;font color=&quot;red&quot;&gt;fork 生成&lt;/font&gt;的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;save与bgsave对比：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;save&lt;/th&gt;
&lt;th&gt;bgsave&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;IO类型&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是否阻塞redis其它命令&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否（在生成子进程调用fork函数时会有短暂阻塞）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复杂度&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;不会消耗额外内存&lt;/td&gt;
&lt;td&gt;不阻塞客户端命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺点&lt;/td&gt;
&lt;td&gt;阻塞客户端命令&lt;/td&gt;
&lt;td&gt;需要fork子进程，消耗内存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; &lt;font color=&quot;red&quot;&gt;配置自动生成rdb文件后台使用的是bgsave方式&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-五种数据类型</title>
    <link href="http://example.com/posts/redis-family/2/"/>
    <id>http://example.com/posts/redis-family/2/</id>
    <published>2023-11-20T16:00:00.000Z</published>
    <updated>2023-11-21T16:29:09.168Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis基本特性&quot;&gt;&lt;a href=&quot;#Redis基本特性&quot; class=&quot;headerlink&quot; title=&quot;Redis基本特性&quot;&gt;&lt;/a&gt;&lt;code&gt;Redis&lt;/code&gt;基本特性&lt;/h2&gt;&lt;p&gt;a) 非关系型的&lt;font color=&quot;red&quot;&gt;键值对&lt;/font&gt;数据库，可以根据键以O(1) 的时间复杂度取出或插入关联值&lt;/p&gt;
&lt;p&gt;b) &lt;code&gt;Redis&lt;/code&gt; 的数据是存在&lt;font color=&quot;red&quot;&gt;内存&lt;/font&gt;中的&lt;/p&gt;
&lt;p&gt;c) 键值对中键的类型可以是字符串，整型，浮点型等，且键是唯一的&lt;/p&gt;
&lt;p&gt;d) 键值对中的值类型可以是string，hash，list，set，sorted set 等&lt;/p&gt;
&lt;p&gt;e) &lt;code&gt;Redis&lt;/code&gt; 内置了复制，磁盘持久化，&lt;code&gt;LUA&lt;/code&gt;脚本，事务，&lt;font color=&quot;orange&quot;&gt;SSL,  ACLs，客户端缓存，客户端代理等功能（6.0新特性）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;f) 通过&lt;code&gt;Redis&lt;/code&gt; 哨兵和&lt;code&gt;Redis Cluster&lt;/code&gt; 模式提供高可用性&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-核心数据结构</title>
    <link href="http://example.com/posts/redis-family/1/"/>
    <id>http://example.com/posts/redis-family/1/</id>
    <published>2023-11-19T16:00:00.000Z</published>
    <updated>2023-11-20T16:32:50.617Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis安装&quot;&gt;&lt;a href=&quot;#Redis安装&quot; class=&quot;headerlink&quot; title=&quot;Redis安装&quot;&gt;&lt;/a&gt;Redis安装&lt;/h2&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://redis.io/download&quot;&gt;http://redis.io/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;# 1、安装gcc
apt-get install gcc
    
# 2、下载redis-7.0.3.tar.gz并解压
wget http://download.redis.io/releases/redis-7.0.3.tar.gz
tar xzf redis-7.0.3.tar.gz
cd redis-7.0.3

# 3、进入到解压好的redis‐7.0.3目录下，进行编译与安装
make
    
# 4、修改配置
daemonize yes #后台启动
protected‐mode no #关闭保护模式，开启的话，只有本机才可以访问redis

# 4.5、需要注释掉bind
# bind 127.0.0.1 -::1

# 5、启动服务
src/redis‐server redis.conf
    
# 6、验证启动是否成功
ps ‐ef | grep redis
    
# 7、进入redis客户端
src/redis‐cli
    
# 8、退出客户端
quit
    
# 9、退出redis服务：（亲测三种都可用）
（1）pkill redis‐server
（2）kill 进程号
（3）src/redis‐cli shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里原计划是安装&lt;code&gt;redis-5.0.3.tar.gz&lt;/code&gt;版本，但是安装解压后执行make命令时一直报错&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;错误信息：&lt;code&gt;collect2.exe: error: ld returned 1 exit status&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;collect2 error ld returned 1 exit status提示出现之前，一般在上面几行都会有其他报错，而collect2 error ld returned 1 exit status所反映的只是其之前一共出现了多少个错误，真正的错误是在其上面出现的那些报错。比如，没有错误，会提示collect2 error ld returned 0 exit status；有两个报错，会提示collect2 error ld returned 2 exit status。所以，真正要解决的是在collect2 error ld returned 1 exit status提示出现之前的那些报错提醒&lt;br&gt;解决问题思路参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_45055622/article/details/126634000&quot;&gt;https://blog.csdn.net/weixin_45055622/article/details/126634000&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尝试过网上给出的多种方案，包括：&lt;/p&gt;
&lt;p&gt;1、添加配置&lt;code&gt;OPT=-O2 -march=i686&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、使用&lt;code&gt;make MALLOC=libc&lt;/code&gt;命令替换make&lt;/p&gt;
&lt;p&gt;3、删除解压包，重新安装&lt;/p&gt;
&lt;p&gt;然而都没有解决问题，最后切换安装版本为&lt;code&gt;redis-7.0.3.tar.gz&lt;/code&gt;解决问题，其他版本未测试&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring-ProxyFactory</title>
    <link href="http://example.com/posts/spring-family/11/"/>
    <id>http://example.com/posts/spring-family/11/</id>
    <published>2023-11-11T16:00:00.000Z</published>
    <updated>2023-11-12T16:46:49.433Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;a href=&quot;#ProxyFactory选择cglib或jdk动态代理原理&quot; class=&quot;headerlink&quot; title=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;/a&gt;ProxyFactory选择cglib或jdk动态代理原理&lt;/h2&gt;&lt;p&gt;ProxyFactory在生成代理对象之前需要决定是使用JDK动态代理还是CGLIB技术：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

    @Override
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        // 如果ProxyFactory的isOptimize为true，Spring认为cglib比jdk动态代理要快
        // 或者isProxyTargetClass为true，
        // 或者被代理对象没有实现接口，
        // 或者只实现了SpringProxy这个接口
        // 那么则利用Cglib进行动态代理，但如果被代理类是接口，或者被代理类已经是进行过JDK动态代理而生成的代理类了则只能进行JDK动态代理

        // 其他情况都会进行JDK动态代理，比如被代理类实现了除SpringProxy接口之外的其他接口

        // 是不是在GraalVM虚拟机上运行
        if (!NativeDetector.inNativeImage() &amp;amp;&amp;amp;
                (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
            // config就是ProxyFactory对象
            Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                        &quot;Either an interface or a target is required for proxy creation.&quot;);
            }
            // targetClass是接口，直接使用Jdk动态代理
            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
                return new JdkDynamicAopProxy(config);
            }
            // 使用Cglib
            return new ObjenesisCglibAopProxy(config);
        }
        else {
            // 使用Jdk动态代理
            return new JdkDynamicAopProxy(config);
        }
    }

    /**
     * Determine whether the supplied {@link AdvisedSupport} has only the
     * {@link org.springframework.aop.SpringProxy} interface specified
     * (or no proxy interfaces specified at all).
     */
    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class&amp;lt;?&amp;gt;[] ifcs = config.getProxiedInterfaces();
        return (ifcs.length == 0 || (ifcs.length == 1 &amp;amp;&amp;amp; SpringProxy.class.isAssignableFrom(ifcs[0])));
    }
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-SpringAOP的实现</title>
    <link href="http://example.com/posts/spring-family/10/"/>
    <id>http://example.com/posts/spring-family/10/</id>
    <published>2023-11-10T16:00:00.000Z</published>
    <updated>2023-11-12T16:59:47.229Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对Spring-AOP的理解&quot;&gt;&lt;a href=&quot;#对Spring-AOP的理解&quot; class=&quot;headerlink&quot; title=&quot;对Spring AOP的理解&quot;&gt;&lt;/a&gt;对Spring AOP的理解&lt;/h2&gt;&lt;p&gt;OOP表示面向对象编程，是一种编程思想，AOP表示面向切面编程，也是一种编程思想&lt;/p&gt;
&lt;p&gt;Spring AOP：Spring为了让程序员更加方便的做到面向切面编程所提供的技术支持&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Spring提供的一套机制，让我们更容易的进行AOP，这套机制就是Spring AOP&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;扩展：用注解的方式来定义Pointcut和Advice，Spring并不是首创，首创是 AspectJ。JBoss 4.0、aspectwerkz 等技术也提供了对于AOP的支持。&lt;/p&gt;
&lt;p&gt;Spring是依赖了AspectJ的，Spring觉得AspectJ中的@Before、@Around等注解比较好用，所以把这些注解直接拿过来用，但是注解底层的解析是由Spring自己做的。&lt;/p&gt;
&lt;p&gt;所以我们在用 Spring时，如果你想用@Before、@Around等注解，是需要单独引入aspecj相关jar包的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;compile group: &#39;org.aspectj&#39;, name: &#39;aspectjrt&#39;, version: &#39;1.9.5&#39;
compile group: &#39;org.aspectj&#39;, name: &#39;aspectjweaver&#39;, version: &#39;1.9.5&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：AspectJ（它自己也是一个项目）是在编译时对字节码进行了修改，可以理解为是在&lt;strong&gt;编译时就会去解析&lt;/strong&gt;@Before这些注解，然后得到代理逻辑，加入到被代理类的字节码中去，所以如果想用AspectJ技术来生成代理对象 ，是需要用单独的AspectJ编译器的。项目中很少用AspectJ编译器，只是用了@Before这些注解，在&lt;strong&gt;启动Spring的过程中&lt;/strong&gt;会去解析这些注解，然后利用动态代理机制生成代理对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-动态代理</title>
    <link href="http://example.com/posts/spring-family/9/"/>
    <id>http://example.com/posts/spring-family/9/</id>
    <published>2023-11-09T16:00:00.000Z</published>
    <updated>2023-11-10T15:51:24.602Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;代理模式：为其他对象提供一种代理以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。&lt;/p&gt;
&lt;p&gt;动态代理可以在&lt;strong&gt;不修改类源码&lt;/strong&gt;的前提下，给类中方法增加额外逻辑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过cglib来实现的代理对象的创建：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;基于&lt;strong&gt;父子类&lt;/strong&gt;，被代理类是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由cglib创建的&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-推断构造方法</title>
    <link href="http://example.com/posts/spring-family/8/"/>
    <id>http://example.com/posts/spring-family/8/</id>
    <published>2023-11-08T16:00:00.000Z</published>
    <updated>2023-11-12T17:07:52.979Z</updated>
    
    
    <summary type="html">&lt;p&gt;Spring中的Bean实例化对象，需要构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常一个类只有一个构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、无参的构造方法，实例化只能选择这一个&lt;/p&gt;
&lt;p&gt;2、有参的构造方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，Spring根据构造方法的参数信息去寻找Bean，然后传给构造方法&lt;/li&gt;
&lt;li&gt;使用ClassPathXmlApplicationContext，表示使用XML的方式来使用bean。在XML中指定手动指定构造方法的参数值；或者配置autowire=constructor让Spring自动去寻找bean做为构造方法参数值。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-循环依赖简述</title>
    <link href="http://example.com/posts/spring-family/7/"/>
    <id>http://example.com/posts/spring-family/7/</id>
    <published>2023-11-07T16:00:00.000Z</published>
    <updated>2023-11-08T15:54:06.169Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;// A依赖了B
class A
{
    public B b;
}

// B依赖了A
class B
{
    public A a;
}

// 循环依赖
A a = new A();
B b = new B();
a.b = b;
b.a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象之间的相互依赖很正常，但是在Spring中由于对象创建要经过Bean的生命周期，所以就有了循环依赖问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入二</title>
    <link href="http://example.com/posts/spring-family/6/"/>
    <id>http://example.com/posts/spring-family/6/</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-08T03:05:47.615Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;findAutowireCandidates-实现&quot;&gt;&lt;a href=&quot;#findAutowireCandidates-实现&quot; class=&quot;headerlink&quot; title=&quot;findAutowireCandidates()实现&quot;&gt;&lt;/a&gt;findAutowireCandidates()实现&lt;/h2&gt;&lt;p&gt;1、找出BeanFactory中类型为type的所有的Bean的名字，根据BeanDefinition就能判断和当前type是不是匹配，不用生成Bean对象&lt;/p&gt;
&lt;p&gt;2、把resolvableDependencies中key为type的对象找出来并添加到result中&lt;/p&gt;
&lt;p&gt;3、遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入&lt;/p&gt;
&lt;p&gt;4、先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断&lt;/p&gt;
&lt;p&gt;5、判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断&lt;/p&gt;
&lt;p&gt;6、如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配&lt;/p&gt;
&lt;p&gt;7、经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入</title>
    <link href="http://example.com/posts/spring-family/5/"/>
    <id>http://example.com/posts/spring-family/5/</id>
    <published>2023-11-04T16:00:00.000Z</published>
    <updated>2023-11-06T15:27:12.591Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;a href=&quot;#Spring中到底有几种依赖注入的方式？&quot; class=&quot;headerlink&quot; title=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;/a&gt;Spring中到底有几种依赖注入的方式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动注入&lt;/p&gt;
&lt;p&gt;a）set方式注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b）构造方法注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;constructor‐arg index=&quot;0&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动注入&lt;/p&gt;
&lt;p&gt;a）XML的autowire自动注入&lt;/p&gt;
&lt;p&gt;b） @Autowired注解的自动注入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean生命周期源码</title>
    <link href="http://example.com/posts/spring-family/4/"/>
    <id>http://example.com/posts/spring-family/4/</id>
    <published>2023-10-28T16:00:00.000Z</published>
    <updated>2023-11-12T16:50:24.940Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生成过程&quot;&gt;&lt;a href=&quot;#Bean的生成过程&quot; class=&quot;headerlink&quot; title=&quot;Bean的生成过程&quot;&gt;&lt;/a&gt;Bean的生成过程&lt;/h2&gt;&lt;p&gt;首先看创建一个Spring容器的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

源码：
/**
 * Create a new AnnotationConfigApplicationContext that needs to be populated
 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
 */
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&quot;spring.context.annotated-bean-reader.create&quot;);
    // 额外会创建StandardEnvironment
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-底层架构核心概念</title>
    <link href="http://example.com/posts/spring-family/3/"/>
    <id>http://example.com/posts/spring-family/3/</id>
    <published>2023-10-26T16:00:00.000Z</published>
    <updated>2023-11-12T17:10:14.206Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring底层核心组件&quot;&gt;&lt;a href=&quot;#Spring底层核心组件&quot; class=&quot;headerlink&quot; title=&quot;Spring底层核心组件&quot;&gt;&lt;/a&gt;Spring底层核心组件&lt;/h2&gt;&lt;h3 id=&quot;BeanDefinition&quot;&gt;&lt;a href=&quot;#BeanDefinition&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition&quot;&gt;&lt;/a&gt;BeanDefinition&lt;/h3&gt;&lt;p&gt;BeanDefinition表示Bean定义，有很多属性用来描述Bean的特点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class，表示Bean类型 &lt;/li&gt;
&lt;li&gt;scope，表示Bean作用域，单例或原型等 &lt;/li&gt;
&lt;li&gt;lazyInit：表示Bean是否是懒加载 &lt;/li&gt;
&lt;li&gt;initMethodName：表示Bean初始化时要执行的方法 &lt;/li&gt;
&lt;li&gt;destroyMethodName：表示Bean销毁时要执行的方法 &lt;/li&gt;
&lt;li&gt;还有很多…&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-手写模拟Spring底层原理</title>
    <link href="http://example.com/posts/spring-family/2/"/>
    <id>http://example.com/posts/spring-family/2/</id>
    <published>2023-10-25T16:00:00.000Z</published>
    <updated>2023-10-26T20:08:39.249Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;模拟大致的底层原理，为学习Spring源码做铺垫。&lt;/p&gt;
&lt;p&gt;实现的功能：扫描路径、依赖注入、aware回调、初始化前、初始化、初始化后、切面&lt;/p&gt;
&lt;p&gt;未实现的功能：构造器推断、循环依赖&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;重点：BeanDefinition、BeanPostProcessor&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;学习Spring源码的重点：设计模式、编码规范、&lt;font color=&quot;red&quot;&gt;设计思想、扩展点&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean的生命周期概述</title>
    <link href="http://example.com/posts/spring-family/1/"/>
    <id>http://example.com/posts/spring-family/1/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2023-10-26T16:43:59.321Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生命周期概述&quot;&gt;&lt;a href=&quot;#Bean的生命周期概述&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期概述&quot;&gt;&lt;/a&gt;Bean的生命周期概述&lt;/h2&gt;&lt;p&gt;入门使用的Spring代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
UserService userService = (UserService) context.getBean(&quot;userService&quot;);
userService.test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思考问题：&lt;/p&gt;
&lt;p&gt;1、第一行代码都做了哪些事情？&lt;/p&gt;
&lt;p&gt;2、第二行代码&lt;code&gt;getBean()&lt;/code&gt;如何实现的？返回的&lt;code&gt;UserService&lt;/code&gt;对象和new创建的对象有什么区别？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-Java内存模型</title>
    <link href="http://example.com/posts/cp-family/20/"/>
    <id>http://example.com/posts/cp-family/20/</id>
    <published>2023-10-21T16:00:00.000Z</published>
    <updated>2023-10-22T12:45:59.679Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;p&gt;在并发编程中，需要处理的两个关键问题： &lt;/p&gt;
&lt;p&gt;1）&lt;font color=&quot;red&quot;&gt;多线程之间如何通信&lt;/font&gt;（线程之间以何种机制来交换数据）&lt;/p&gt;
&lt;p&gt;2）&lt;font color=&quot;red&quot;&gt;多线程之间如何同步&lt;/font&gt;（控制不同线程间操作发生的相对顺序）&lt;/p&gt;
&lt;p&gt;线程之间常用的通信机制有两种：共享内存和消息传递，Java采用的是&lt;strong&gt;共享内存&lt;/strong&gt;模型&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发三大特性</title>
    <link href="http://example.com/posts/cp-family/19/"/>
    <id>http://example.com/posts/cp-family/19/</id>
    <published>2023-10-20T16:00:00.000Z</published>
    <updated>2023-10-21T15:33:03.918Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;并发三大特性&quot;&gt;&lt;a href=&quot;#并发三大特性&quot; class=&quot;headerlink&quot; title=&quot;并发三大特性&quot;&gt;&lt;/a&gt;并发三大特性&lt;/h2&gt;&lt;p&gt;并发编程Bug源头：原子性、可见性和有序性问题。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子性&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注意：不采取任何的原子性保障措施的自增操作并不是原子性的，比如i++操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool(二)</title>
    <link href="http://example.com/posts/cp-family/18/"/>
    <id>http://example.com/posts/cp-family/18/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-10-24T15:52:07.177Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Fork-x2F-Join框架介绍&quot;&gt;&lt;a href=&quot;#Fork-x2F-Join框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Fork/Join框架介绍&quot;&gt;&lt;/a&gt;Fork/Join框架介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Fork-x2F-Join&quot;&gt;&lt;a href=&quot;#什么是Fork-x2F-Join&quot; class=&quot;headerlink&quot; title=&quot;什么是Fork/Join&quot;&gt;&lt;/a&gt;什么是Fork/Join&lt;/h3&gt;&lt;p&gt;Fork/Join是一个是一个并行计算的框架，主要就是用来&lt;font color=&quot;red&quot;&gt;支持分治任务模型。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;核心思想：将一个大任务分成许多小任务，然后并行执行这些小任务，最终将它们的结果合并成一个大的结果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool</title>
    <link href="http://example.com/posts/cp-family/17/"/>
    <id>http://example.com/posts/cp-family/17/</id>
    <published>2023-10-18T16:00:00.000Z</published>
    <updated>2023-10-19T16:16:25.545Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ForkJoinPool&quot;&gt;&lt;a href=&quot;#ForkJoinPool&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinPool&quot;&gt;&lt;/a&gt;ForkJoinPool&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;算法题：如何充分利用多核CPU的性能，快速对一个2千万大小的数组进行排序？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想：分解 求解 合并&lt;/p&gt;
&lt;p&gt;分治思想是&lt;font color=&quot;red&quot;&gt;将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想的步骤如下：&lt;/p&gt;
&lt;p&gt;1、分解：将要解决的问题划分成若干规模较小的同类问题；（子问题不能无限小，所以通常会设置阈值）&lt;/p&gt;
&lt;p&gt;2、求解：当子问题划分得足够小时，用较简单的方法解决；&lt;/p&gt;
&lt;p&gt;3、合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/p&gt;
&lt;p&gt;计算机十大经典算法中的归并排序、快速排序、二分查找都是基于分治思想实现的算法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序（Merge Sort）演示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池底层原理</title>
    <link href="http://example.com/posts/cp-family/16/"/>
    <id>http://example.com/posts/cp-family/16/</id>
    <published>2023-10-17T16:00:00.000Z</published>
    <updated>2023-10-18T14:31:32.329Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池底层原理&quot;&gt;&lt;a href=&quot;#线程池底层原理&quot; class=&quot;headerlink&quot; title=&quot;线程池底层原理&quot;&gt;&lt;/a&gt;线程池底层原理&lt;/h2&gt;&lt;h3 id=&quot;为什么需要线程池？&quot;&gt;&lt;a href=&quot;#为什么需要线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池？&quot;&gt;&lt;/a&gt;为什么需要线程池？&lt;/h3&gt;&lt;p&gt;每次新开线程去执行任务，运行完任务销毁线程，都会消耗资源（操作系统级别的线程）&lt;/p&gt;
&lt;p&gt;线程池就可以提前创建线程、保留线程，节约资源、节省掉开辟线程和销毁线程的消耗、提高效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
