<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-11T15:24:13.065Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程-JUC并发工具类</title>
    <link href="http://example.com/posts/cp-family/9/"/>
    <id>http://example.com/posts/cp-family/9/</id>
    <published>2023-10-10T16:00:00.000Z</published>
    <updated>2023-10-11T15:24:13.065Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;a href=&quot;#常用并发同步工具类的真实应用场景&quot; class=&quot;headerlink&quot; title=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;/a&gt;常用并发同步工具类的真实应用场景&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;思考：并发编程是为了解决什么问题？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;性能 + 线程安全（正确性）&lt;/font&gt; &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;分工和同步解决性能问题，互斥解决安全性问题&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Jdk提供了比synchronized更加高级的各种同步工具，包括&lt;strong&gt;ReentrantLock、Semaphore、CountDownLatch、 CyclicBarrier&lt;/strong&gt;等，可以实现更加丰富的多线程操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发安全</title>
    <link href="http://example.com/posts/cp-family/8/"/>
    <id>http://example.com/posts/cp-family/8/</id>
    <published>2023-10-09T16:00:00.000Z</published>
    <updated>2023-10-10T15:29:13.826Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h2&gt;&lt;h3 id=&quot;什么是线程安全性？&quot;&gt;&lt;a href=&quot;#什么是线程安全性？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全性？&quot;&gt;&lt;/a&gt;什么是线程安全性？&lt;/h3&gt;&lt;p&gt;代码在并发情况下使用时，总是能表现出正确的行为；反之，未实现线程安全的代码，表现的行为是不可预知的，有可能正确，而绝大多数的情况下是错误的。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;官方说法：线程的行为（尤其是在未正确同步的情况下）可能会造成混淆并且违反直觉。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注意：代码执行10000次，哪怕只有一次错误，也是线程不安全的；无论执行多少次都正确，才是线程安全的。&lt;/p&gt;
&lt;p&gt;如果要实现线程安全性，就要保证类是线程安全的。在《Java并发编程实战》中，定义“类是线程安全的”如下：&lt;/p&gt;
&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;p&gt;思考：Java中的bean是不是线程安全的？&lt;/p&gt;
&lt;p&gt;无状态的bean是线程安全的，另外如果做了并发处理也是线程安全的&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-CAS&amp;Atomic</title>
    <link href="http://example.com/posts/cp-family/7/"/>
    <id>http://example.com/posts/cp-family/7/</id>
    <published>2023-10-08T16:00:00.000Z</published>
    <updated>2023-10-09T16:24:09.265Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CAS-amp-Atomic原子操作详解&quot;&gt;&lt;a href=&quot;#CAS-amp-Atomic原子操作详解&quot; class=&quot;headerlink&quot; title=&quot;CAS&amp;amp;Atomic原子操作详解&quot;&gt;&lt;/a&gt;CAS&amp;amp;Atomic原子操作详解&lt;/h2&gt;&lt;h3 id=&quot;什么是原子操作？如何实现原子操作？&quot;&gt;&lt;a href=&quot;#什么是原子操作？如何实现原子操作？&quot; class=&quot;headerlink&quot; title=&quot;什么是原子操作？如何实现原子操作？&quot;&gt;&lt;/a&gt;什么是原子操作？如何实现原子操作？&lt;/h3&gt;&lt;p&gt;工作中经常使用事务，而事务的一大特性就是原子性（事务具有ACID四大特性），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。&lt;/p&gt;
&lt;p&gt;实现原子操作可以使用锁，锁机制，满足基本的需求没有问题，但是有的时候我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;锁机制存在的问题：如果被阻塞的线程优先级很高很重要怎么办；如果获得锁的线程一直不释放锁怎么办；还有可能出现一些例如死锁之类的情况；其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;为了解决锁机制的这些问题，Java提供了Atomic系列的原子操作类。&lt;/p&gt;
&lt;p&gt;原子操作类是基于操作系统提供的指令&lt;code&gt;cmpxchg&lt;/code&gt;（每个厂家所实现的具体算法并不一样，但是原理基本一样）。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。&lt;/p&gt;
&lt;p&gt;CAS的基本思路是：如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。Java中的Atomic系列原子操作类就是利用了循环CAS来实现，即在一个循环里不断的做CAS操作，直到成功为止。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ThreadLocal</title>
    <link href="http://example.com/posts/cp-family/6/"/>
    <id>http://example.com/posts/cp-family/6/</id>
    <published>2023-10-07T16:00:00.000Z</published>
    <updated>2023-10-08T19:51:40.386Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要有ThreadLocal&quot;&gt;&lt;a href=&quot;#为什么要有ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;为什么要有ThreadLocal&quot;&gt;&lt;/a&gt;为什么要有ThreadLocal&lt;/h2&gt;&lt;p&gt;ThreadLocal为每个线程都提供了&lt;strong&gt;变量的副本&lt;/strong&gt;，使得每个线程在某一时间访问到的并非同一个对象，这样就&lt;strong&gt;隔离&lt;/strong&gt;了多个线程对数据的数据共享。&lt;/p&gt;
&lt;p&gt;ThreadLocal和Synchonized都用于解决多线程并发访问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用&lt;strong&gt;锁的机制&lt;/strong&gt;，使变量或代码块在某一时刻仅能被一个线程访问，ThreadLocal则是&lt;strong&gt;副本机制&lt;/strong&gt;，此时不论多少线程并发访问都是线程安全的。&lt;/p&gt;
&lt;p&gt;ThreadLocal最主要的应用场景就是&lt;strong&gt;跨方法进行参数传递&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Web容器中，每个完整的请求周期会由一个线程来处理。ThreadLocal为线程提供变量副本，可以进行事务操作，&lt;strong&gt;存储事务的信息&lt;/strong&gt;；可以&lt;strong&gt;保存数据库连接&lt;/strong&gt;，Spring就是使用一个ThreadLocal来实现“绑定连接到线程”；可以&lt;strong&gt;保存Session会话&lt;/strong&gt;进行管理；在微服务领域，&lt;strong&gt;链路跟踪&lt;/strong&gt;中的traceId传递也是利用了ThreadLocal。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-CompleteableFuture</title>
    <link href="http://example.com/posts/cp-family/5/"/>
    <id>http://example.com/posts/cp-family/5/</id>
    <published>2023-10-06T16:00:00.000Z</published>
    <updated>2023-10-07T15:03:18.119Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CompleteableFuture&quot;&gt;&lt;a href=&quot;#CompleteableFuture&quot; class=&quot;headerlink&quot; title=&quot;CompleteableFuture&quot;&gt;&lt;/a&gt;CompleteableFuture&lt;/h2&gt;&lt;p&gt;JDK1.8才新加入的一个实现类CompletableFuture，实现了Future， CompletionStage两个接口。实现了Future接口，意味着可以通过阻塞或者轮询的方式获得结果。CompletionStage是一个接口，从命名上看得知是一个完成的阶段，它代表了一个特定的计算的阶段，可以同步或者异步的被完成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-等待/通知机制</title>
    <link href="http://example.com/posts/cp-family/4/"/>
    <id>http://example.com/posts/cp-family/4/</id>
    <published>2023-10-05T16:00:00.000Z</published>
    <updated>2023-10-11T09:57:36.463Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;等待-x2F-通知机制&quot;&gt;&lt;a href=&quot;#等待-x2F-通知机制&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-深入学习Java的线程二</title>
    <link href="http://example.com/posts/cp-family/3/"/>
    <id>http://example.com/posts/cp-family/3/</id>
    <published>2023-10-04T16:00:00.000Z</published>
    <updated>2023-10-05T18:30:38.899Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程和协程&quot;&gt;&lt;a href=&quot;#线程和协程&quot; class=&quot;headerlink&quot; title=&quot;线程和协程&quot;&gt;&lt;/a&gt;线程和协程&lt;/h2&gt;&lt;p&gt;线程是操作系统层面的实体，那么Java中的线程怎么和操作系统的线程对应起来？&lt;/p&gt;
&lt;p&gt;任何语言实现线程主要有三种方式：使用内核线程实现（1:1实现)，使用用户线程实现（1:N实现），使用用户线程加轻量级进程混合实现（N:M实现）。Java就是第三种混合实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-深入学习Java的线程</title>
    <link href="http://example.com/posts/cp-family/2/"/>
    <id>http://example.com/posts/cp-family/2/</id>
    <published>2023-10-03T16:00:00.000Z</published>
    <updated>2023-10-05T16:51:33.659Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程的状态-x2F-生命周期&quot;&gt;&lt;a href=&quot;#线程的状态-x2F-生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的状态/生命周期&quot;&gt;&lt;/a&gt;线程的状态/生命周期&lt;/h2&gt;&lt;p&gt;Java中线程的状态分为6种：&lt;/p&gt;
&lt;p&gt;1、初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。&lt;/p&gt;
&lt;p&gt;2、运行(RUNNABLE)：包括就绪（ready）和运行中（running）两种状态。&lt;/p&gt;
&lt;p&gt;线程对象创建后，调用了该对象的start()方法。等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。&lt;/p&gt;
&lt;p&gt;3、阻塞(BLOCKED)：表示线程阻塞于锁。&lt;font color=&quot;red&quot;&gt;仅在等待synchronized释放资源时会进入此状态&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;4、等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。&lt;/p&gt;
&lt;p&gt;5、超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。&lt;/p&gt;
&lt;p&gt;6、终止(TERMINATED)：表示该线程已经执行完毕。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/cp/cp-1.png&quot; alt=&quot;cp-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发和线程初识</title>
    <link href="http://example.com/posts/cp-family/1/"/>
    <id>http://example.com/posts/cp-family/1/</id>
    <published>2023-10-02T16:00:00.000Z</published>
    <updated>2023-10-04T09:26:09.526Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么我们要学习并发编程？&quot;&gt;&lt;a href=&quot;#为什么我们要学习并发编程？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们要学习并发编程？&quot;&gt;&lt;/a&gt;为什么我们要学习并发编程？&lt;/h2&gt;&lt;p&gt;面试必备；大厂技术标配；非大厂面试加分项；善用并发编程可以提升技术话语权&lt;/p&gt;
&lt;h3 id=&quot;为什么开发中需要并发编程？&quot;&gt;&lt;a href=&quot;#为什么开发中需要并发编程？&quot; class=&quot;headerlink&quot; title=&quot;为什么开发中需要并发编程？&quot;&gt;&lt;/a&gt;为什么开发中需要并发编程？&lt;/h3&gt;&lt;p&gt;(1) 加快响应用户的时间&lt;/p&gt;
&lt;p&gt;(2) 使你的代码模块化，异步化，简单化&lt;/p&gt;
&lt;p&gt;(3) 充分利用CPU的资源&lt;font color=&quot;red&quot;&gt;，多核CPU，超线程技术&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM-常量池</title>
    <link href="http://example.com/posts/jvm-family/12/"/>
    <id>http://example.com/posts/jvm-family/12/</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-10-01T05:26:30.362Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Class常量池与运行时常量池&quot;&gt;&lt;a href=&quot;#Class常量池与运行时常量池&quot; class=&quot;headerlink&quot; title=&quot;Class常量池与运行时常量池&quot;&gt;&lt;/a&gt;Class常量池与运行时常量池&lt;/h2&gt;&lt;p&gt;Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池(constant pool table)&lt;strong&gt;，用于存放编译期生成的各种&lt;/strong&gt;字面量(Literal)和符号引用(Symbolic References)**。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class文件内部结构组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class字节码文件由魔数，主次版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量等信息组成&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-调优实战</title>
    <link href="http://example.com/posts/jvm-family/11/"/>
    <id>http://example.com/posts/jvm-family/11/</id>
    <published>2023-09-29T16:00:00.000Z</published>
    <updated>2023-10-01T05:26:11.508Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阿里巴巴Arthas&quot;&gt;&lt;a href=&quot;#阿里巴巴Arthas&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴Arthas&quot;&gt;&lt;/a&gt;阿里巴巴Arthas&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Arthas&lt;/strong&gt; 是 Alibaba 在 2018 年 9 月开源的 &lt;strong&gt;Java 诊断&lt;/strong&gt;工具。支持 JDK6+， 采用命令行交互模式，可以方便的定位和诊断线上程序运行问题。&lt;strong&gt;Arthas&lt;/strong&gt; 官方文档十分详细，详见：&lt;a href=&quot;https://alibaba.github.io/arthas&quot;&gt;&lt;em&gt;https://alibaba.github.io/arthas&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-调优工具</title>
    <link href="http://example.com/posts/jvm-family/10/"/>
    <id>http://example.com/posts/jvm-family/10/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-09-29T14:45:20.107Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM调优工具&quot;&gt;&lt;a href=&quot;#JVM调优工具&quot; class=&quot;headerlink&quot; title=&quot;JVM调优工具&quot;&gt;&lt;/a&gt;JVM调优工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Jmap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看内存信息，实例个数以及占用内存大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;jmap -histo 14904  #查看历史生成的实例
jmap -histo:live 14904  #查看当前存活的实例，执行过程中可能会触发一次full gc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/tun-1.png&quot; alt=&quot;tun-1&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;num：序号&lt;/li&gt;
&lt;li&gt;instances：实例数量&lt;/li&gt;
&lt;li&gt;bytes：占用空间大小&lt;/li&gt;
&lt;li&gt;class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器ZGC</title>
    <link href="http://example.com/posts/jvm-family/9/"/>
    <id>http://example.com/posts/jvm-family/9/</id>
    <published>2023-09-27T16:00:00.000Z</published>
    <updated>2023-10-05T18:32:45.498Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ZGC收集器-XX-UseZGC&quot;&gt;&lt;a href=&quot;#ZGC收集器-XX-UseZGC&quot; class=&quot;headerlink&quot; title=&quot;ZGC收集器(-XX:+UseZGC)&quot;&gt;&lt;/a&gt;ZGC收集器(-XX:+UseZGC)&lt;/h2&gt;&lt;p&gt;参考文章：&lt;a href=&quot;https://wiki.openjdk.java.net/display/zgc/Main&quot;&gt;https://wiki.openjdk.java.net/display/zgc/Main&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf&quot;&gt;http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ZGC源自于Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器，是JDK 11中新加入的具有实验性质的&lt;strong&gt;低延迟&lt;/strong&gt;垃圾收集器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/zgc-1.png&quot; alt=&quot;zgc-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器G1</title>
    <link href="http://example.com/posts/jvm-family/8/"/>
    <id>http://example.com/posts/jvm-family/8/</id>
    <published>2023-09-26T16:00:00.000Z</published>
    <updated>2023-09-27T14:19:28.757Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;G1收集器-XX-UseG1GC&quot;&gt;&lt;a href=&quot;#G1收集器-XX-UseG1GC&quot; class=&quot;headerlink&quot; title=&quot;G1收集器(-XX:+UseG1GC)&quot;&gt;&lt;/a&gt;G1收集器(-XX:+UseG1GC)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;G1（Garbage-First）是一款面向服务器的垃圾收集器，&lt;font color=&quot;red&quot;&gt;主要针对配备多颗处理器及大容量内存的机器&lt;/font&gt;。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JDK 7版本正式启用，是&lt;font color=&quot;red&quot;&gt;JDK 9以后的默认垃圾收集器&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/go-1.png&quot; alt=&quot;go-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集底层算法实现</title>
    <link href="http://example.com/posts/jvm-family/7/"/>
    <id>http://example.com/posts/jvm-family/7/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T11:18:13.631Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;三色标记&quot;&gt;&lt;a href=&quot;#三色标记&quot; class=&quot;headerlink&quot; title=&quot;三色标记&quot;&gt;&lt;/a&gt;三色标记&lt;/h2&gt;&lt;p&gt;在并发标记的过程中，应用线程和垃圾收集线程一起跑，对象的引用很可能发生变化，于是有了&lt;strong&gt;多标和漏标&lt;/strong&gt;的情况（这里指标记为非垃圾对象），其中&lt;strong&gt;漏标&lt;/strong&gt;的问题主要引入&lt;strong&gt;三色标记&lt;/strong&gt;算法来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;白色&lt;/strong&gt;： 表示对象尚未被垃圾收集器访问过。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;黑色：全部扫描完成，包括其成员变量；灰色：部分扫描完成；白色：未扫描过&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集算法</title>
    <link href="http://example.com/posts/jvm-family/6/"/>
    <id>http://example.com/posts/jvm-family/6/</id>
    <published>2023-09-24T16:00:00.000Z</published>
    <updated>2023-09-25T15:26:56.475Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM有哪些垃圾回收算法&quot;&gt;&lt;a href=&quot;#JVM有哪些垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;JVM有哪些垃圾回收算法&quot;&gt;&lt;/a&gt;JVM有哪些垃圾回收算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来一半&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;新生代每次收集都有大量的对象死去，选择复制算法只需要复制少量的存活对象即可；老年代的对象存活概率较高，没有额外的空间提供给复制算法，必须选择标记-清除或标记-整理算法。标记-清除和标记-整理算法比复制算法慢10倍以上&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存分配机制</title>
    <link href="http://example.com/posts/jvm-family/5/"/>
    <id>http://example.com/posts/jvm-family/5/</id>
    <published>2023-09-23T16:00:00.000Z</published>
    <updated>2023-09-24T14:17:34.716Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象内存分配&quot;&gt;&lt;a href=&quot;#对象内存分配&quot; class=&quot;headerlink&quot; title=&quot;对象内存分配&quot;&gt;&lt;/a&gt;对象内存分配&lt;/h2&gt;&lt;p&gt;对象内存分配流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/oma.png&quot; alt=&quot;oma&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-对象创建</title>
    <link href="http://example.com/posts/jvm-family/4/"/>
    <id>http://example.com/posts/jvm-family/4/</id>
    <published>2023-09-22T16:00:00.000Z</published>
    <updated>2023-09-23T15:06:23.360Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h2&gt;&lt;p&gt;Java中提供的几种创建对象的方式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Header&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;使用new关键字&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用Class的newInstance方法&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用Constructor类的newInstance方法&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用clone方法&lt;/td&gt;
&lt;td&gt;没有调用构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用反序列化&lt;/td&gt;
&lt;td&gt;没有调用构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存模型</title>
    <link href="http://example.com/posts/jvm-family/3/"/>
    <id>http://example.com/posts/jvm-family/3/</id>
    <published>2023-09-21T16:00:00.000Z</published>
    <updated>2023-09-23T14:16:23.238Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/jvm/jmm.png&quot; alt=&quot;jmm&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-自定义类加载器</title>
    <link href="http://example.com/posts/jvm-family/2/"/>
    <id>http://example.com/posts/jvm-family/2/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-09-21T10:21:47.695Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;自定义类加载器&quot;&gt;&lt;a href=&quot;#自定义类加载器&quot; class=&quot;headerlink&quot; title=&quot;自定义类加载器&quot;&gt;&lt;/a&gt;自定义类加载器&lt;/h2&gt;&lt;p&gt;自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了&lt;strong&gt;双亲委派机制&lt;/strong&gt;，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是&lt;strong&gt;重写findClass方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;1、继承 java.lang.ClassLoader 类，2、重写findClass方法&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
</feed>
