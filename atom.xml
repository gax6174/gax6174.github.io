<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-03T16:24:26.384Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程-并发和线程初识</title>
    <link href="http://example.com/posts/cp-family/1/"/>
    <id>http://example.com/posts/cp-family/1/</id>
    <published>2023-10-02T16:00:00.000Z</published>
    <updated>2023-10-03T16:24:26.384Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么我们要学习并发编程？&quot;&gt;&lt;a href=&quot;#为什么我们要学习并发编程？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们要学习并发编程？&quot;&gt;&lt;/a&gt;为什么我们要学习并发编程？&lt;/h2&gt;&lt;p&gt;面试必备；大厂技术标配；非大厂面试加分项；善用并发编程可以提升技术话语权&lt;/p&gt;
&lt;h3 id=&quot;为什么开发中需要并发编程？&quot;&gt;&lt;a href=&quot;#为什么开发中需要并发编程？&quot; class=&quot;headerlink&quot; title=&quot;为什么开发中需要并发编程？&quot;&gt;&lt;/a&gt;为什么开发中需要并发编程？&lt;/h3&gt;&lt;p&gt;(1) 加快响应用户的时间&lt;/p&gt;
&lt;p&gt;(2) 使你的代码模块化，异步化，简单化&lt;/p&gt;
&lt;p&gt;(3) 充分利用CPU的资源&lt;font color=&quot;red&quot;&gt;，多核CPU，超线程技术&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-常量池</title>
    <link href="http://example.com/posts/jvm-family/12/"/>
    <id>http://example.com/posts/jvm-family/12/</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-10-01T05:26:30.362Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Class常量池与运行时常量池&quot;&gt;&lt;a href=&quot;#Class常量池与运行时常量池&quot; class=&quot;headerlink&quot; title=&quot;Class常量池与运行时常量池&quot;&gt;&lt;/a&gt;Class常量池与运行时常量池&lt;/h2&gt;&lt;p&gt;Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池(constant pool table)&lt;strong&gt;，用于存放编译期生成的各种&lt;/strong&gt;字面量(Literal)和符号引用(Symbolic References)**。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class文件内部结构组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class字节码文件由魔数，主次版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量等信息组成&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-调优实战</title>
    <link href="http://example.com/posts/jvm-family/11/"/>
    <id>http://example.com/posts/jvm-family/11/</id>
    <published>2023-09-29T16:00:00.000Z</published>
    <updated>2023-10-01T05:26:11.508Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阿里巴巴Arthas&quot;&gt;&lt;a href=&quot;#阿里巴巴Arthas&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴Arthas&quot;&gt;&lt;/a&gt;阿里巴巴Arthas&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Arthas&lt;/strong&gt; 是 Alibaba 在 2018 年 9 月开源的 &lt;strong&gt;Java 诊断&lt;/strong&gt;工具。支持 JDK6+， 采用命令行交互模式，可以方便的定位和诊断线上程序运行问题。&lt;strong&gt;Arthas&lt;/strong&gt; 官方文档十分详细，详见：&lt;a href=&quot;https://alibaba.github.io/arthas&quot;&gt;&lt;em&gt;https://alibaba.github.io/arthas&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-调优工具</title>
    <link href="http://example.com/posts/jvm-family/10/"/>
    <id>http://example.com/posts/jvm-family/10/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-09-29T14:45:20.107Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM调优工具&quot;&gt;&lt;a href=&quot;#JVM调优工具&quot; class=&quot;headerlink&quot; title=&quot;JVM调优工具&quot;&gt;&lt;/a&gt;JVM调优工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Jmap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看内存信息，实例个数以及占用内存大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;jmap -histo 14904  #查看历史生成的实例
jmap -histo:live 14904  #查看当前存活的实例，执行过程中可能会触发一次full gc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/tun-1.png&quot; alt=&quot;tun-1&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;num：序号&lt;/li&gt;
&lt;li&gt;instances：实例数量&lt;/li&gt;
&lt;li&gt;bytes：占用空间大小&lt;/li&gt;
&lt;li&gt;class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器ZGC</title>
    <link href="http://example.com/posts/jvm-family/9/"/>
    <id>http://example.com/posts/jvm-family/9/</id>
    <published>2023-09-27T16:00:00.000Z</published>
    <updated>2023-09-29T11:48:50.382Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ZGC收集器-XX-UseZGC&quot;&gt;&lt;a href=&quot;#ZGC收集器-XX-UseZGC&quot; class=&quot;headerlink&quot; title=&quot;ZGC收集器(-XX:+UseZGC)&quot;&gt;&lt;/a&gt;ZGC收集器(-XX:+UseZGC)&lt;/h2&gt;&lt;p&gt;参考文章：&lt;a href=&quot;https://wiki.openjdk.java.net/display/zgc/Main&quot;&gt;https://wiki.openjdk.java.net/display/zgc/Main&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf&quot;&gt;http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ZGC源自于Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器，是JDK 11中新加入的具有实验性质的&lt;strong&gt;低延迟&lt;/strong&gt;垃圾收集器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/zgc-1.png&quot; alt=&quot;zgc-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器G1</title>
    <link href="http://example.com/posts/jvm-family/8/"/>
    <id>http://example.com/posts/jvm-family/8/</id>
    <published>2023-09-26T16:00:00.000Z</published>
    <updated>2023-09-27T14:19:28.757Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;G1收集器-XX-UseG1GC&quot;&gt;&lt;a href=&quot;#G1收集器-XX-UseG1GC&quot; class=&quot;headerlink&quot; title=&quot;G1收集器(-XX:+UseG1GC)&quot;&gt;&lt;/a&gt;G1收集器(-XX:+UseG1GC)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;G1（Garbage-First）是一款面向服务器的垃圾收集器，&lt;font color=&quot;red&quot;&gt;主要针对配备多颗处理器及大容量内存的机器&lt;/font&gt;。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JDK 7版本正式启用，是&lt;font color=&quot;red&quot;&gt;JDK 9以后的默认垃圾收集器&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/go-1.png&quot; alt=&quot;go-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集底层算法实现</title>
    <link href="http://example.com/posts/jvm-family/7/"/>
    <id>http://example.com/posts/jvm-family/7/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T11:18:13.631Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;三色标记&quot;&gt;&lt;a href=&quot;#三色标记&quot; class=&quot;headerlink&quot; title=&quot;三色标记&quot;&gt;&lt;/a&gt;三色标记&lt;/h2&gt;&lt;p&gt;在并发标记的过程中，应用线程和垃圾收集线程一起跑，对象的引用很可能发生变化，于是有了&lt;strong&gt;多标和漏标&lt;/strong&gt;的情况（这里指标记为非垃圾对象），其中&lt;strong&gt;漏标&lt;/strong&gt;的问题主要引入&lt;strong&gt;三色标记&lt;/strong&gt;算法来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;白色&lt;/strong&gt;： 表示对象尚未被垃圾收集器访问过。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;黑色：全部扫描完成，包括其成员变量；灰色：部分扫描完成；白色：未扫描过&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集算法</title>
    <link href="http://example.com/posts/jvm-family/6/"/>
    <id>http://example.com/posts/jvm-family/6/</id>
    <published>2023-09-24T16:00:00.000Z</published>
    <updated>2023-09-25T15:26:56.475Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM有哪些垃圾回收算法&quot;&gt;&lt;a href=&quot;#JVM有哪些垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;JVM有哪些垃圾回收算法&quot;&gt;&lt;/a&gt;JVM有哪些垃圾回收算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来一半&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;新生代每次收集都有大量的对象死去，选择复制算法只需要复制少量的存活对象即可；老年代的对象存活概率较高，没有额外的空间提供给复制算法，必须选择标记-清除或标记-整理算法。标记-清除和标记-整理算法比复制算法慢10倍以上&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存分配机制</title>
    <link href="http://example.com/posts/jvm-family/5/"/>
    <id>http://example.com/posts/jvm-family/5/</id>
    <published>2023-09-23T16:00:00.000Z</published>
    <updated>2023-09-24T14:17:34.716Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象内存分配&quot;&gt;&lt;a href=&quot;#对象内存分配&quot; class=&quot;headerlink&quot; title=&quot;对象内存分配&quot;&gt;&lt;/a&gt;对象内存分配&lt;/h2&gt;&lt;p&gt;对象内存分配流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm/oma.png&quot; alt=&quot;oma&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-对象创建</title>
    <link href="http://example.com/posts/jvm-family/4/"/>
    <id>http://example.com/posts/jvm-family/4/</id>
    <published>2023-09-22T16:00:00.000Z</published>
    <updated>2023-09-23T15:06:23.360Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h2&gt;&lt;p&gt;Java中提供的几种创建对象的方式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Header&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;使用new关键字&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用Class的newInstance方法&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用Constructor类的newInstance方法&lt;/td&gt;
&lt;td&gt;调用了构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用clone方法&lt;/td&gt;
&lt;td&gt;没有调用构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用反序列化&lt;/td&gt;
&lt;td&gt;没有调用构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存模型</title>
    <link href="http://example.com/posts/jvm-family/3/"/>
    <id>http://example.com/posts/jvm-family/3/</id>
    <published>2023-09-21T16:00:00.000Z</published>
    <updated>2023-09-23T14:16:23.238Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/jvm/jmm.png&quot; alt=&quot;jmm&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-自定义类加载器</title>
    <link href="http://example.com/posts/jvm-family/2/"/>
    <id>http://example.com/posts/jvm-family/2/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-09-21T10:21:47.695Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;自定义类加载器&quot;&gt;&lt;a href=&quot;#自定义类加载器&quot; class=&quot;headerlink&quot; title=&quot;自定义类加载器&quot;&gt;&lt;/a&gt;自定义类加载器&lt;/h2&gt;&lt;p&gt;自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了&lt;strong&gt;双亲委派机制&lt;/strong&gt;，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是&lt;strong&gt;重写findClass方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;1、继承 java.lang.ClassLoader 类，2、重写findClass方法&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-类加载机制</title>
    <link href="http://example.com/posts/jvm-family/1/"/>
    <id>http://example.com/posts/jvm-family/1/</id>
    <published>2023-09-19T16:00:00.000Z</published>
    <updated>2023-09-20T15:23:28.847Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;类加载运行全过程&quot;&gt;&lt;a href=&quot;#类加载运行全过程&quot; class=&quot;headerlink&quot; title=&quot;类加载运行全过程&quot;&gt;&lt;/a&gt;类加载运行全过程&lt;/h2&gt;&lt;p&gt;用java命令运行某个类的main函数启动程序时，首先需要通过&lt;strong&gt;类加载器&lt;/strong&gt;把主类加载到JVM&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.gax.jvm;

public class Math
{
    public static final int initData = 666;
    
    public int compute()
    {
        int a = 1;
        int b = 2;
        int c = (a + b) * 10;
        return c;
    }
    
    public static void main(String[] args)
    {
        Math math = new Math();
        System.out.println(math.compute());
    }
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-日志机制二</title>
    <link href="http://example.com/posts/mysql-family/12/"/>
    <id>http://example.com/posts/mysql-family/12/</id>
    <published>2023-09-17T16:00:00.000Z</published>
    <updated>2023-09-18T17:15:07.323Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CPU、内存和磁盘的简单模型&quot;&gt;&lt;a href=&quot;#CPU、内存和磁盘的简单模型&quot; class=&quot;headerlink&quot; title=&quot;CPU、内存和磁盘的简单模型&quot;&gt;&lt;/a&gt;CPU、内存和磁盘的简单模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mysql/log2-1.png&quot; alt=&quot;log2-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-日志机制</title>
    <link href="http://example.com/posts/mysql-family/11/"/>
    <id>http://example.com/posts/mysql-family/11/</id>
    <published>2023-09-16T16:00:00.000Z</published>
    <updated>2023-09-17T14:32:44.432Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL日志机制&quot;&gt;&lt;a href=&quot;#MySQL日志机制&quot; class=&quot;headerlink&quot; title=&quot;MySQL日志机制&quot;&gt;&lt;/a&gt;MySQL日志机制&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mysql/log-1.png&quot; alt=&quot;log-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-InnoDB底层原理</title>
    <link href="http://example.com/posts/mysql-family/10/"/>
    <id>http://example.com/posts/mysql-family/10/</id>
    <published>2023-09-15T16:00:00.000Z</published>
    <updated>2023-09-16T14:20:00.859Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL的内部组件结构&quot;&gt;&lt;a href=&quot;#MySQL的内部组件结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL的内部组件结构&quot;&gt;&lt;/a&gt;MySQL的内部组件结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mysql/idb-1.png&quot; alt=&quot;idb-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-MVCC多版本并发控制机制</title>
    <link href="http://example.com/posts/mysql-family/9/"/>
    <id>http://example.com/posts/mysql-family/9/</id>
    <published>2023-09-14T16:00:00.000Z</published>
    <updated>2023-09-15T12:14:00.564Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL在可重复读隔离级别下如何保证事务较高的隔离性？&quot;&gt;&lt;a href=&quot;#MySQL在可重复读隔离级别下如何保证事务较高的隔离性？&quot; class=&quot;headerlink&quot; title=&quot;MySQL在可重复读隔离级别下如何保证事务较高的隔离性？&quot;&gt;&lt;/a&gt;MySQL在可重复读隔离级别下如何保证事务较高的隔离性？&lt;/h2&gt;&lt;p&gt;同样的sql查询语句在一个事务里多次执行查询结果相同，就算其它事务对数据有修改也不会影响当前事务sql语句的查询结果。这个隔离性就是靠MVCC(&lt;strong&gt;Multi-Version Concurrency Control&lt;/strong&gt;)机制来保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。&lt;/p&gt;
&lt;p&gt;MySQL在&lt;strong&gt;读已提交和可重复读&lt;/strong&gt;隔离级别下都实现了MVCC机制。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;MySQL在RC和RR隔离级别下，事务第一次查询数据表生成全部数据的&lt;strong&gt;快照&lt;/strong&gt;功能，就是通过MVCC多版本控制实现的&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-锁机制</title>
    <link href="http://example.com/posts/mysql-family/8/"/>
    <id>http://example.com/posts/mysql-family/8/</id>
    <published>2023-09-13T16:00:00.000Z</published>
    <updated>2023-09-14T15:46:49.986Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;锁机制详解&quot;&gt;&lt;a href=&quot;#锁机制详解&quot; class=&quot;headerlink&quot; title=&quot;锁机制详解&quot;&gt;&lt;/a&gt;锁机制详解&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制。&lt;/p&gt;
&lt;p&gt;在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何&lt;strong&gt;保证数据并发访问的一致性、有效性&lt;/strong&gt;是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-事务</title>
    <link href="http://example.com/posts/mysql-family/7/"/>
    <id>http://example.com/posts/mysql-family/7/</id>
    <published>2023-09-12T16:00:00.000Z</published>
    <updated>2023-09-14T08:32:36.985Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;数据库并发执行多个事务对相同的一批数据进行增删改查操作，可能就会导致脏写、脏读、不可重复读、幻读这些问题。这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了&lt;strong&gt;事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制&lt;/strong&gt;，用一整套机制来&lt;strong&gt;解决多事务并发问题&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-优化三</title>
    <link href="http://example.com/posts/mysql-family/6/"/>
    <id>http://example.com/posts/mysql-family/6/</id>
    <published>2023-09-11T16:00:00.000Z</published>
    <updated>2023-09-12T17:16:09.991Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;分页查询优化&quot;&gt;&lt;a href=&quot;#分页查询优化&quot; class=&quot;headerlink&quot; title=&quot;分页查询优化&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;分页查询优化&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;预置表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `employees` (
    `id` INT ( 11 ) NOT NULL AUTO_INCREMENT,
    `name` VARCHAR ( 24 ) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,
    `age` INT ( 11 ) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,
    `position` VARCHAR ( 20 ) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;职位&#39;,
    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入职时间&#39;,
    PRIMARY KEY ( `id` ),
    KEY `idx_name_age_position` ( `name`, `age`, `position` ) USING BTREE 
) ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT = &#39;员工记录表&#39;;

drop procedure if exists insert_emp; 
delimiter ;;
create procedure insert_emp()        
begin
  declare i int;                    
  set i=1;                          
  while(i&amp;lt;=100000)do                 
    insert into employees(name,age,position) values(CONCAT(&#39;gax&#39;,i),i,&#39;dev&#39;);  
    set i=i+1;                       
  end while;
end;;
delimiter ;
call insert_emp();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析业务上可能遇到的分页SQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from employees limit 10000,10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
