<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-12T16:46:49.433Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-ProxyFactory</title>
    <link href="http://example.com/posts/spring-family/11/"/>
    <id>http://example.com/posts/spring-family/11/</id>
    <published>2023-11-11T16:00:00.000Z</published>
    <updated>2023-11-12T16:46:49.433Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;a href=&quot;#ProxyFactory选择cglib或jdk动态代理原理&quot; class=&quot;headerlink&quot; title=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;/a&gt;ProxyFactory选择cglib或jdk动态代理原理&lt;/h2&gt;&lt;p&gt;ProxyFactory在生成代理对象之前需要决定是使用JDK动态代理还是CGLIB技术：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

    @Override
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        // 如果ProxyFactory的isOptimize为true，Spring认为cglib比jdk动态代理要快
        // 或者isProxyTargetClass为true，
        // 或者被代理对象没有实现接口，
        // 或者只实现了SpringProxy这个接口
        // 那么则利用Cglib进行动态代理，但如果被代理类是接口，或者被代理类已经是进行过JDK动态代理而生成的代理类了则只能进行JDK动态代理

        // 其他情况都会进行JDK动态代理，比如被代理类实现了除SpringProxy接口之外的其他接口

        // 是不是在GraalVM虚拟机上运行
        if (!NativeDetector.inNativeImage() &amp;amp;&amp;amp;
                (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
            // config就是ProxyFactory对象
            Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                        &quot;Either an interface or a target is required for proxy creation.&quot;);
            }
            // targetClass是接口，直接使用Jdk动态代理
            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
                return new JdkDynamicAopProxy(config);
            }
            // 使用Cglib
            return new ObjenesisCglibAopProxy(config);
        }
        else {
            // 使用Jdk动态代理
            return new JdkDynamicAopProxy(config);
        }
    }

    /**
     * Determine whether the supplied {@link AdvisedSupport} has only the
     * {@link org.springframework.aop.SpringProxy} interface specified
     * (or no proxy interfaces specified at all).
     */
    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class&amp;lt;?&amp;gt;[] ifcs = config.getProxiedInterfaces();
        return (ifcs.length == 0 || (ifcs.length == 1 &amp;amp;&amp;amp; SpringProxy.class.isAssignableFrom(ifcs[0])));
    }
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-SpringAOP的实现</title>
    <link href="http://example.com/posts/spring-family/10/"/>
    <id>http://example.com/posts/spring-family/10/</id>
    <published>2023-11-10T16:00:00.000Z</published>
    <updated>2023-11-12T16:59:47.229Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对Spring-AOP的理解&quot;&gt;&lt;a href=&quot;#对Spring-AOP的理解&quot; class=&quot;headerlink&quot; title=&quot;对Spring AOP的理解&quot;&gt;&lt;/a&gt;对Spring AOP的理解&lt;/h2&gt;&lt;p&gt;OOP表示面向对象编程，是一种编程思想，AOP表示面向切面编程，也是一种编程思想&lt;/p&gt;
&lt;p&gt;Spring AOP：Spring为了让程序员更加方便的做到面向切面编程所提供的技术支持&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Spring提供的一套机制，让我们更容易的进行AOP，这套机制就是Spring AOP&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;扩展：用注解的方式来定义Pointcut和Advice，Spring并不是首创，首创是 AspectJ。JBoss 4.0、aspectwerkz 等技术也提供了对于AOP的支持。&lt;/p&gt;
&lt;p&gt;Spring是依赖了AspectJ的，Spring觉得AspectJ中的@Before、@Around等注解比较好用，所以把这些注解直接拿过来用，但是注解底层的解析是由Spring自己做的。&lt;/p&gt;
&lt;p&gt;所以我们在用 Spring时，如果你想用@Before、@Around等注解，是需要单独引入aspecj相关jar包的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;compile group: &#39;org.aspectj&#39;, name: &#39;aspectjrt&#39;, version: &#39;1.9.5&#39;
compile group: &#39;org.aspectj&#39;, name: &#39;aspectjweaver&#39;, version: &#39;1.9.5&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：AspectJ（它自己也是一个项目）是在编译时对字节码进行了修改，可以理解为是在&lt;strong&gt;编译时就会去解析&lt;/strong&gt;@Before这些注解，然后得到代理逻辑，加入到被代理类的字节码中去，所以如果想用AspectJ技术来生成代理对象 ，是需要用单独的AspectJ编译器的。项目中很少用AspectJ编译器，只是用了@Before这些注解，在&lt;strong&gt;启动Spring的过程中&lt;/strong&gt;会去解析这些注解，然后利用动态代理机制生成代理对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-动态代理</title>
    <link href="http://example.com/posts/spring-family/9/"/>
    <id>http://example.com/posts/spring-family/9/</id>
    <published>2023-11-09T16:00:00.000Z</published>
    <updated>2023-11-10T15:51:24.602Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;代理模式：为其他对象提供一种代理以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。&lt;/p&gt;
&lt;p&gt;动态代理可以在&lt;strong&gt;不修改类源码&lt;/strong&gt;的前提下，给类中方法增加额外逻辑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过cglib来实现的代理对象的创建：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;基于&lt;strong&gt;父子类&lt;/strong&gt;，被代理类是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由cglib创建的&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-推断构造方法</title>
    <link href="http://example.com/posts/spring-family/8/"/>
    <id>http://example.com/posts/spring-family/8/</id>
    <published>2023-11-08T16:00:00.000Z</published>
    <updated>2023-11-12T17:07:52.979Z</updated>
    
    
    <summary type="html">&lt;p&gt;Spring中的Bean实例化对象，需要构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常一个类只有一个构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、无参的构造方法，实例化只能选择这一个&lt;/p&gt;
&lt;p&gt;2、有参的构造方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，Spring根据构造方法的参数信息去寻找Bean，然后传给构造方法&lt;/li&gt;
&lt;li&gt;使用ClassPathXmlApplicationContext，表示使用XML的方式来使用bean。在XML中指定手动指定构造方法的参数值；或者配置autowire=constructor让Spring自动去寻找bean做为构造方法参数值。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-循环依赖简述</title>
    <link href="http://example.com/posts/spring-family/7/"/>
    <id>http://example.com/posts/spring-family/7/</id>
    <published>2023-11-07T16:00:00.000Z</published>
    <updated>2023-11-08T15:54:06.169Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;// A依赖了B
class A
{
    public B b;
}

// B依赖了A
class B
{
    public A a;
}

// 循环依赖
A a = new A();
B b = new B();
a.b = b;
b.a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象之间的相互依赖很正常，但是在Spring中由于对象创建要经过Bean的生命周期，所以就有了循环依赖问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入二</title>
    <link href="http://example.com/posts/spring-family/6/"/>
    <id>http://example.com/posts/spring-family/6/</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-08T03:05:47.615Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;findAutowireCandidates-实现&quot;&gt;&lt;a href=&quot;#findAutowireCandidates-实现&quot; class=&quot;headerlink&quot; title=&quot;findAutowireCandidates()实现&quot;&gt;&lt;/a&gt;findAutowireCandidates()实现&lt;/h2&gt;&lt;p&gt;1、找出BeanFactory中类型为type的所有的Bean的名字，根据BeanDefinition就能判断和当前type是不是匹配，不用生成Bean对象&lt;/p&gt;
&lt;p&gt;2、把resolvableDependencies中key为type的对象找出来并添加到result中&lt;/p&gt;
&lt;p&gt;3、遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入&lt;/p&gt;
&lt;p&gt;4、先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断&lt;/p&gt;
&lt;p&gt;5、判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断&lt;/p&gt;
&lt;p&gt;6、如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配&lt;/p&gt;
&lt;p&gt;7、经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入</title>
    <link href="http://example.com/posts/spring-family/5/"/>
    <id>http://example.com/posts/spring-family/5/</id>
    <published>2023-11-04T16:00:00.000Z</published>
    <updated>2023-11-06T15:27:12.591Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;a href=&quot;#Spring中到底有几种依赖注入的方式？&quot; class=&quot;headerlink&quot; title=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;/a&gt;Spring中到底有几种依赖注入的方式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动注入&lt;/p&gt;
&lt;p&gt;a）set方式注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b）构造方法注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;constructor‐arg index=&quot;0&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动注入&lt;/p&gt;
&lt;p&gt;a）XML的autowire自动注入&lt;/p&gt;
&lt;p&gt;b） @Autowired注解的自动注入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean生命周期源码</title>
    <link href="http://example.com/posts/spring-family/4/"/>
    <id>http://example.com/posts/spring-family/4/</id>
    <published>2023-10-28T16:00:00.000Z</published>
    <updated>2023-11-12T16:50:24.940Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生成过程&quot;&gt;&lt;a href=&quot;#Bean的生成过程&quot; class=&quot;headerlink&quot; title=&quot;Bean的生成过程&quot;&gt;&lt;/a&gt;Bean的生成过程&lt;/h2&gt;&lt;p&gt;首先看创建一个Spring容器的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

源码：
/**
 * Create a new AnnotationConfigApplicationContext that needs to be populated
 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
 */
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&quot;spring.context.annotated-bean-reader.create&quot;);
    // 额外会创建StandardEnvironment
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-底层架构核心概念</title>
    <link href="http://example.com/posts/spring-family/3/"/>
    <id>http://example.com/posts/spring-family/3/</id>
    <published>2023-10-26T16:00:00.000Z</published>
    <updated>2023-11-12T17:10:14.206Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring底层核心组件&quot;&gt;&lt;a href=&quot;#Spring底层核心组件&quot; class=&quot;headerlink&quot; title=&quot;Spring底层核心组件&quot;&gt;&lt;/a&gt;Spring底层核心组件&lt;/h2&gt;&lt;h3 id=&quot;BeanDefinition&quot;&gt;&lt;a href=&quot;#BeanDefinition&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition&quot;&gt;&lt;/a&gt;BeanDefinition&lt;/h3&gt;&lt;p&gt;BeanDefinition表示Bean定义，有很多属性用来描述Bean的特点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class，表示Bean类型 &lt;/li&gt;
&lt;li&gt;scope，表示Bean作用域，单例或原型等 &lt;/li&gt;
&lt;li&gt;lazyInit：表示Bean是否是懒加载 &lt;/li&gt;
&lt;li&gt;initMethodName：表示Bean初始化时要执行的方法 &lt;/li&gt;
&lt;li&gt;destroyMethodName：表示Bean销毁时要执行的方法 &lt;/li&gt;
&lt;li&gt;还有很多…&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-手写模拟Spring底层原理</title>
    <link href="http://example.com/posts/spring-family/2/"/>
    <id>http://example.com/posts/spring-family/2/</id>
    <published>2023-10-25T16:00:00.000Z</published>
    <updated>2023-10-26T20:08:39.249Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;模拟大致的底层原理，为学习Spring源码做铺垫。&lt;/p&gt;
&lt;p&gt;实现的功能：扫描路径、依赖注入、aware回调、初始化前、初始化、初始化后、切面&lt;/p&gt;
&lt;p&gt;未实现的功能：构造器推断、循环依赖&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;重点：BeanDefinition、BeanPostProcessor&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;学习Spring源码的重点：设计模式、编码规范、&lt;font color=&quot;red&quot;&gt;设计思想、扩展点&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean的生命周期概述</title>
    <link href="http://example.com/posts/spring-family/1/"/>
    <id>http://example.com/posts/spring-family/1/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2023-10-26T16:43:59.321Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生命周期概述&quot;&gt;&lt;a href=&quot;#Bean的生命周期概述&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期概述&quot;&gt;&lt;/a&gt;Bean的生命周期概述&lt;/h2&gt;&lt;p&gt;入门使用的Spring代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
UserService userService = (UserService) context.getBean(&quot;userService&quot;);
userService.test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思考问题：&lt;/p&gt;
&lt;p&gt;1、第一行代码都做了哪些事情？&lt;/p&gt;
&lt;p&gt;2、第二行代码&lt;code&gt;getBean()&lt;/code&gt;如何实现的？返回的&lt;code&gt;UserService&lt;/code&gt;对象和new创建的对象有什么区别？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-Java内存模型</title>
    <link href="http://example.com/posts/cp-family/20/"/>
    <id>http://example.com/posts/cp-family/20/</id>
    <published>2023-10-21T16:00:00.000Z</published>
    <updated>2023-10-22T12:45:59.679Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;p&gt;在并发编程中，需要处理的两个关键问题： &lt;/p&gt;
&lt;p&gt;1）&lt;font color=&quot;red&quot;&gt;多线程之间如何通信&lt;/font&gt;（线程之间以何种机制来交换数据）&lt;/p&gt;
&lt;p&gt;2）&lt;font color=&quot;red&quot;&gt;多线程之间如何同步&lt;/font&gt;（控制不同线程间操作发生的相对顺序）&lt;/p&gt;
&lt;p&gt;线程之间常用的通信机制有两种：共享内存和消息传递，Java采用的是&lt;strong&gt;共享内存&lt;/strong&gt;模型&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发三大特性</title>
    <link href="http://example.com/posts/cp-family/19/"/>
    <id>http://example.com/posts/cp-family/19/</id>
    <published>2023-10-20T16:00:00.000Z</published>
    <updated>2023-10-21T15:33:03.918Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;并发三大特性&quot;&gt;&lt;a href=&quot;#并发三大特性&quot; class=&quot;headerlink&quot; title=&quot;并发三大特性&quot;&gt;&lt;/a&gt;并发三大特性&lt;/h2&gt;&lt;p&gt;并发编程Bug源头：原子性、可见性和有序性问题。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子性&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注意：不采取任何的原子性保障措施的自增操作并不是原子性的，比如i++操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool(二)</title>
    <link href="http://example.com/posts/cp-family/18/"/>
    <id>http://example.com/posts/cp-family/18/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-10-24T15:52:07.177Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Fork-x2F-Join框架介绍&quot;&gt;&lt;a href=&quot;#Fork-x2F-Join框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Fork/Join框架介绍&quot;&gt;&lt;/a&gt;Fork/Join框架介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Fork-x2F-Join&quot;&gt;&lt;a href=&quot;#什么是Fork-x2F-Join&quot; class=&quot;headerlink&quot; title=&quot;什么是Fork/Join&quot;&gt;&lt;/a&gt;什么是Fork/Join&lt;/h3&gt;&lt;p&gt;Fork/Join是一个是一个并行计算的框架，主要就是用来&lt;font color=&quot;red&quot;&gt;支持分治任务模型。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;核心思想：将一个大任务分成许多小任务，然后并行执行这些小任务，最终将它们的结果合并成一个大的结果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool</title>
    <link href="http://example.com/posts/cp-family/17/"/>
    <id>http://example.com/posts/cp-family/17/</id>
    <published>2023-10-18T16:00:00.000Z</published>
    <updated>2023-10-19T16:16:25.545Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ForkJoinPool&quot;&gt;&lt;a href=&quot;#ForkJoinPool&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinPool&quot;&gt;&lt;/a&gt;ForkJoinPool&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;算法题：如何充分利用多核CPU的性能，快速对一个2千万大小的数组进行排序？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想：分解 求解 合并&lt;/p&gt;
&lt;p&gt;分治思想是&lt;font color=&quot;red&quot;&gt;将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想的步骤如下：&lt;/p&gt;
&lt;p&gt;1、分解：将要解决的问题划分成若干规模较小的同类问题；（子问题不能无限小，所以通常会设置阈值）&lt;/p&gt;
&lt;p&gt;2、求解：当子问题划分得足够小时，用较简单的方法解决；&lt;/p&gt;
&lt;p&gt;3、合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/p&gt;
&lt;p&gt;计算机十大经典算法中的归并排序、快速排序、二分查找都是基于分治思想实现的算法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序（Merge Sort）演示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池底层原理</title>
    <link href="http://example.com/posts/cp-family/16/"/>
    <id>http://example.com/posts/cp-family/16/</id>
    <published>2023-10-17T16:00:00.000Z</published>
    <updated>2023-10-18T14:31:32.329Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池底层原理&quot;&gt;&lt;a href=&quot;#线程池底层原理&quot; class=&quot;headerlink&quot; title=&quot;线程池底层原理&quot;&gt;&lt;/a&gt;线程池底层原理&lt;/h2&gt;&lt;h3 id=&quot;为什么需要线程池？&quot;&gt;&lt;a href=&quot;#为什么需要线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池？&quot;&gt;&lt;/a&gt;为什么需要线程池？&lt;/h3&gt;&lt;p&gt;每次新开线程去执行任务，运行完任务销毁线程，都会消耗资源（操作系统级别的线程）&lt;/p&gt;
&lt;p&gt;线程池就可以提前创建线程、保留线程，节约资源、节省掉开辟线程和销毁线程的消耗、提高效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池</title>
    <link href="http://example.com/posts/cp-family/15/"/>
    <id>http://example.com/posts/cp-family/15/</id>
    <published>2023-10-16T16:00:00.000Z</published>
    <updated>2023-10-17T15:35:42.847Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么需要线程池？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次新开线程去执行任务，运行完任务销毁线程，都会消耗资源（操作系统级别的线程）&lt;/p&gt;
&lt;p&gt;线程池就可以提前创建线程、保留线程，节约资源、节省掉开辟线程和销毁线程的消耗、提高效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列二</title>
    <link href="http://example.com/posts/cp-family/14/"/>
    <id>http://example.com/posts/cp-family/14/</id>
    <published>2023-10-15T16:00:00.000Z</published>
    <updated>2023-10-16T14:35:59.765Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阻塞队列介绍&quot;&gt;&lt;a href=&quot;#阻塞队列介绍&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列介绍&quot;&gt;&lt;/a&gt;阻塞队列介绍&lt;/h2&gt;&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;先进先出的线性表；一端进行插入，另一端进行删除；允许出队的一端为队头，允许入队的一端为队尾&lt;/p&gt;
&lt;p&gt;包括数组、链表、延迟队列，天然适合生产者和消费者的模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列</title>
    <link href="http://example.com/posts/cp-family/13/"/>
    <id>http://example.com/posts/cp-family/13/</id>
    <published>2023-10-14T16:00:00.000Z</published>
    <updated>2023-10-24T14:10:37.817Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阻塞队列介绍&quot;&gt;&lt;a href=&quot;#阻塞队列介绍&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列介绍&quot;&gt;&lt;/a&gt;阻塞队列介绍&lt;/h2&gt;&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;先进先出的线性表；一端进行插入，另一端进行删除；允许出队的一端为队头，允许入队的一端为队尾&lt;/p&gt;
&lt;p&gt;包括数组、链表、延迟队列，天然适合生产者和消费者的模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ReentrantLock源码</title>
    <link href="http://example.com/posts/cp-family/12/"/>
    <id>http://example.com/posts/cp-family/12/</id>
    <published>2023-10-13T16:00:00.000Z</published>
    <updated>2023-10-18T13:26:25.704Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ReentrantLock源码分析&quot;&gt;&lt;a href=&quot;#ReentrantLock源码分析&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock源码分析&quot;&gt;&lt;/a&gt;ReentrantLock源码分析&lt;/h2&gt;&lt;p&gt;ReentrantLock是一种&lt;strong&gt;基于AQS框架&lt;/strong&gt;的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized是一种&lt;strong&gt;互斥锁&lt;/strong&gt;，可以&lt;strong&gt;保证线程安全&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
