<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-26T20:08:39.249Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-手写模拟Spring底层原理</title>
    <link href="http://example.com/posts/spring-family/2/"/>
    <id>http://example.com/posts/spring-family/2/</id>
    <published>2023-10-25T16:00:00.000Z</published>
    <updated>2023-10-26T20:08:39.249Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;模拟大致的底层原理，为学习Spring源码做铺垫。&lt;/p&gt;
&lt;p&gt;实现的功能：扫描路径、依赖注入、aware回调、初始化前、初始化、初始化后、切面&lt;/p&gt;
&lt;p&gt;未实现的功能：构造器推断、循环依赖&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;重点：BeanDefinition、BeanPostProcessor&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;学习Spring源码的重点：设计模式、编码规范、&lt;font color=&quot;red&quot;&gt;设计思想、扩展点&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean的生命周期概述</title>
    <link href="http://example.com/posts/spring-family/1/"/>
    <id>http://example.com/posts/spring-family/1/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2023-10-26T16:43:59.321Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生命周期概述&quot;&gt;&lt;a href=&quot;#Bean的生命周期概述&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期概述&quot;&gt;&lt;/a&gt;Bean的生命周期概述&lt;/h2&gt;&lt;p&gt;入门使用的Spring代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
UserService userService = (UserService) context.getBean(&quot;userService&quot;);
userService.test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思考问题：&lt;/p&gt;
&lt;p&gt;1、第一行代码都做了哪些事情？&lt;/p&gt;
&lt;p&gt;2、第二行代码&lt;code&gt;getBean()&lt;/code&gt;如何实现的？返回的&lt;code&gt;UserService&lt;/code&gt;对象和new创建的对象有什么区别？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-Java内存模型</title>
    <link href="http://example.com/posts/cp-family/20/"/>
    <id>http://example.com/posts/cp-family/20/</id>
    <published>2023-10-21T16:00:00.000Z</published>
    <updated>2023-10-22T12:45:59.679Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;p&gt;在并发编程中，需要处理的两个关键问题： &lt;/p&gt;
&lt;p&gt;1）&lt;font color=&quot;red&quot;&gt;多线程之间如何通信&lt;/font&gt;（线程之间以何种机制来交换数据）&lt;/p&gt;
&lt;p&gt;2）&lt;font color=&quot;red&quot;&gt;多线程之间如何同步&lt;/font&gt;（控制不同线程间操作发生的相对顺序）&lt;/p&gt;
&lt;p&gt;线程之间常用的通信机制有两种：共享内存和消息传递，Java采用的是&lt;strong&gt;共享内存&lt;/strong&gt;模型&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发三大特性</title>
    <link href="http://example.com/posts/cp-family/19/"/>
    <id>http://example.com/posts/cp-family/19/</id>
    <published>2023-10-20T16:00:00.000Z</published>
    <updated>2023-10-21T15:33:03.918Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;并发三大特性&quot;&gt;&lt;a href=&quot;#并发三大特性&quot; class=&quot;headerlink&quot; title=&quot;并发三大特性&quot;&gt;&lt;/a&gt;并发三大特性&lt;/h2&gt;&lt;p&gt;并发编程Bug源头：原子性、可见性和有序性问题。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子性&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注意：不采取任何的原子性保障措施的自增操作并不是原子性的，比如i++操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool(二)</title>
    <link href="http://example.com/posts/cp-family/18/"/>
    <id>http://example.com/posts/cp-family/18/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-10-24T15:52:07.177Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Fork-x2F-Join框架介绍&quot;&gt;&lt;a href=&quot;#Fork-x2F-Join框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Fork/Join框架介绍&quot;&gt;&lt;/a&gt;Fork/Join框架介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Fork-x2F-Join&quot;&gt;&lt;a href=&quot;#什么是Fork-x2F-Join&quot; class=&quot;headerlink&quot; title=&quot;什么是Fork/Join&quot;&gt;&lt;/a&gt;什么是Fork/Join&lt;/h3&gt;&lt;p&gt;Fork/Join是一个是一个并行计算的框架，主要就是用来&lt;font color=&quot;red&quot;&gt;支持分治任务模型。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;核心思想：将一个大任务分成许多小任务，然后并行执行这些小任务，最终将它们的结果合并成一个大的结果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池ForkJoinPool</title>
    <link href="http://example.com/posts/cp-family/17/"/>
    <id>http://example.com/posts/cp-family/17/</id>
    <published>2023-10-18T16:00:00.000Z</published>
    <updated>2023-10-19T16:16:25.545Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ForkJoinPool&quot;&gt;&lt;a href=&quot;#ForkJoinPool&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinPool&quot;&gt;&lt;/a&gt;ForkJoinPool&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;算法题：如何充分利用多核CPU的性能，快速对一个2千万大小的数组进行排序？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想：分解 求解 合并&lt;/p&gt;
&lt;p&gt;分治思想是&lt;font color=&quot;red&quot;&gt;将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;分治思想的步骤如下：&lt;/p&gt;
&lt;p&gt;1、分解：将要解决的问题划分成若干规模较小的同类问题；（子问题不能无限小，所以通常会设置阈值）&lt;/p&gt;
&lt;p&gt;2、求解：当子问题划分得足够小时，用较简单的方法解决；&lt;/p&gt;
&lt;p&gt;3、合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/p&gt;
&lt;p&gt;计算机十大经典算法中的归并排序、快速排序、二分查找都是基于分治思想实现的算法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归并排序（Merge Sort）演示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池底层原理</title>
    <link href="http://example.com/posts/cp-family/16/"/>
    <id>http://example.com/posts/cp-family/16/</id>
    <published>2023-10-17T16:00:00.000Z</published>
    <updated>2023-10-18T14:31:32.329Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池底层原理&quot;&gt;&lt;a href=&quot;#线程池底层原理&quot; class=&quot;headerlink&quot; title=&quot;线程池底层原理&quot;&gt;&lt;/a&gt;线程池底层原理&lt;/h2&gt;&lt;h3 id=&quot;为什么需要线程池？&quot;&gt;&lt;a href=&quot;#为什么需要线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池？&quot;&gt;&lt;/a&gt;为什么需要线程池？&lt;/h3&gt;&lt;p&gt;每次新开线程去执行任务，运行完任务销毁线程，都会消耗资源（操作系统级别的线程）&lt;/p&gt;
&lt;p&gt;线程池就可以提前创建线程、保留线程，节约资源、节省掉开辟线程和销毁线程的消耗、提高效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池</title>
    <link href="http://example.com/posts/cp-family/15/"/>
    <id>http://example.com/posts/cp-family/15/</id>
    <published>2023-10-16T16:00:00.000Z</published>
    <updated>2023-10-17T15:35:42.847Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么需要线程池？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次新开线程去执行任务，运行完任务销毁线程，都会消耗资源（操作系统级别的线程）&lt;/p&gt;
&lt;p&gt;线程池就可以提前创建线程、保留线程，节约资源、节省掉开辟线程和销毁线程的消耗、提高效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列二</title>
    <link href="http://example.com/posts/cp-family/14/"/>
    <id>http://example.com/posts/cp-family/14/</id>
    <published>2023-10-15T16:00:00.000Z</published>
    <updated>2023-10-16T14:35:59.765Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阻塞队列介绍&quot;&gt;&lt;a href=&quot;#阻塞队列介绍&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列介绍&quot;&gt;&lt;/a&gt;阻塞队列介绍&lt;/h2&gt;&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;先进先出的线性表；一端进行插入，另一端进行删除；允许出队的一端为队头，允许入队的一端为队尾&lt;/p&gt;
&lt;p&gt;包括数组、链表、延迟队列，天然适合生产者和消费者的模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列</title>
    <link href="http://example.com/posts/cp-family/13/"/>
    <id>http://example.com/posts/cp-family/13/</id>
    <published>2023-10-14T16:00:00.000Z</published>
    <updated>2023-10-24T14:10:37.817Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;阻塞队列介绍&quot;&gt;&lt;a href=&quot;#阻塞队列介绍&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列介绍&quot;&gt;&lt;/a&gt;阻塞队列介绍&lt;/h2&gt;&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;先进先出的线性表；一端进行插入，另一端进行删除；允许出队的一端为队头，允许入队的一端为队尾&lt;/p&gt;
&lt;p&gt;包括数组、链表、延迟队列，天然适合生产者和消费者的模式&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ReentrantLock源码</title>
    <link href="http://example.com/posts/cp-family/12/"/>
    <id>http://example.com/posts/cp-family/12/</id>
    <published>2023-10-13T16:00:00.000Z</published>
    <updated>2023-10-18T13:26:25.704Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ReentrantLock源码分析&quot;&gt;&lt;a href=&quot;#ReentrantLock源码分析&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock源码分析&quot;&gt;&lt;/a&gt;ReentrantLock源码分析&lt;/h2&gt;&lt;p&gt;ReentrantLock是一种&lt;strong&gt;基于AQS框架&lt;/strong&gt;的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized是一种&lt;strong&gt;互斥锁&lt;/strong&gt;，可以&lt;strong&gt;保证线程安全&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-AQS独占锁</title>
    <link href="http://example.com/posts/cp-family/11/"/>
    <id>http://example.com/posts/cp-family/11/</id>
    <published>2023-10-12T16:00:00.000Z</published>
    <updated>2023-10-20T13:58:09.258Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;深入理解AQS独占锁&quot;&gt;&lt;a href=&quot;#深入理解AQS独占锁&quot; class=&quot;headerlink&quot; title=&quot;深入理解AQS独占锁&quot;&gt;&lt;/a&gt;深入理解AQS独占锁&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;思考：如何设计独占锁&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-JUC并发工具类二</title>
    <link href="http://example.com/posts/cp-family/10/"/>
    <id>http://example.com/posts/cp-family/10/</id>
    <published>2023-10-11T16:00:00.000Z</published>
    <updated>2023-10-24T13:31:32.620Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;a href=&quot;#常用并发同步工具类的真实应用场景&quot; class=&quot;headerlink&quot; title=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;/a&gt;常用并发同步工具类的真实应用场景&lt;/h2&gt;&lt;h3 id=&quot;CountDownLatch（闭锁）&quot;&gt;&lt;a href=&quot;#CountDownLatch（闭锁）&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch（闭锁）&quot;&gt;&lt;/a&gt;CountDownLatch（闭锁）&lt;/h3&gt;&lt;p&gt;描述：一个同步协助类，允许一个或多个线程等待，直到其他线程完成操作集。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;初始化时定义一个计数器count，每次调用countDown方法计数器减一，调用await方法阻塞直到计数值为0&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-JUC并发工具类</title>
    <link href="http://example.com/posts/cp-family/9/"/>
    <id>http://example.com/posts/cp-family/9/</id>
    <published>2023-10-10T16:00:00.000Z</published>
    <updated>2023-10-24T12:34:28.988Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;a href=&quot;#常用并发同步工具类的真实应用场景&quot; class=&quot;headerlink&quot; title=&quot;常用并发同步工具类的真实应用场景&quot;&gt;&lt;/a&gt;常用并发同步工具类的真实应用场景&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;思考：并发编程是为了解决什么问题？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;性能 + 线程安全（正确性）&lt;/font&gt; &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;分工和同步解决性能问题，互斥解决安全性问题&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Jdk提供了比synchronized更加高级的各种同步工具，包括&lt;strong&gt;ReentrantLock、Semaphore、CountDownLatch、 CyclicBarrier&lt;/strong&gt;等，可以实现更加丰富的多线程操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发安全</title>
    <link href="http://example.com/posts/cp-family/8/"/>
    <id>http://example.com/posts/cp-family/8/</id>
    <published>2023-10-09T16:00:00.000Z</published>
    <updated>2023-10-10T15:29:13.826Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h2&gt;&lt;h3 id=&quot;什么是线程安全性？&quot;&gt;&lt;a href=&quot;#什么是线程安全性？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全性？&quot;&gt;&lt;/a&gt;什么是线程安全性？&lt;/h3&gt;&lt;p&gt;代码在并发情况下使用时，总是能表现出正确的行为；反之，未实现线程安全的代码，表现的行为是不可预知的，有可能正确，而绝大多数的情况下是错误的。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;官方说法：线程的行为（尤其是在未正确同步的情况下）可能会造成混淆并且违反直觉。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注意：代码执行10000次，哪怕只有一次错误，也是线程不安全的；无论执行多少次都正确，才是线程安全的。&lt;/p&gt;
&lt;p&gt;如果要实现线程安全性，就要保证类是线程安全的。在《Java并发编程实战》中，定义“类是线程安全的”如下：&lt;/p&gt;
&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;p&gt;思考：Java中的bean是不是线程安全的？&lt;/p&gt;
&lt;p&gt;无状态的bean是线程安全的，另外如果做了并发处理也是线程安全的&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-CAS&amp;Atomic</title>
    <link href="http://example.com/posts/cp-family/7/"/>
    <id>http://example.com/posts/cp-family/7/</id>
    <published>2023-10-08T16:00:00.000Z</published>
    <updated>2023-10-19T09:03:51.942Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CAS-amp-Atomic原子操作详解&quot;&gt;&lt;a href=&quot;#CAS-amp-Atomic原子操作详解&quot; class=&quot;headerlink&quot; title=&quot;CAS&amp;amp;Atomic原子操作详解&quot;&gt;&lt;/a&gt;CAS&amp;amp;Atomic原子操作详解&lt;/h2&gt;&lt;h3 id=&quot;什么是原子操作？如何实现原子操作？&quot;&gt;&lt;a href=&quot;#什么是原子操作？如何实现原子操作？&quot; class=&quot;headerlink&quot; title=&quot;什么是原子操作？如何实现原子操作？&quot;&gt;&lt;/a&gt;什么是原子操作？如何实现原子操作？&lt;/h3&gt;&lt;p&gt;工作中经常使用事务，而事务的一大特性就是原子性（事务具有ACID四大特性），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。&lt;/p&gt;
&lt;p&gt;实现原子操作可以使用锁，锁机制，满足基本的需求没有问题，但是有的时候我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;锁机制存在的问题：如果被阻塞的线程优先级很高很重要怎么办；如果获得锁的线程一直不释放锁怎么办；还有可能出现一些例如死锁之类的情况；其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;为了解决锁机制的这些问题，Java提供了Atomic系列的原子操作类。&lt;/p&gt;
&lt;p&gt;原子操作类是基于操作系统提供的指令&lt;code&gt;cmpxchg&lt;/code&gt;（每个厂家所实现的具体算法并不一样，但是原理基本一样）。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。&lt;/p&gt;
&lt;p&gt;CAS的基本思路是：如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。Java中的Atomic系列原子操作类就是利用了循环CAS来实现，即在一个循环里不断的做CAS操作，直到成功为止。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ThreadLocal</title>
    <link href="http://example.com/posts/cp-family/6/"/>
    <id>http://example.com/posts/cp-family/6/</id>
    <published>2023-10-07T16:00:00.000Z</published>
    <updated>2023-10-08T19:51:40.386Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要有ThreadLocal&quot;&gt;&lt;a href=&quot;#为什么要有ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;为什么要有ThreadLocal&quot;&gt;&lt;/a&gt;为什么要有ThreadLocal&lt;/h2&gt;&lt;p&gt;ThreadLocal为每个线程都提供了&lt;strong&gt;变量的副本&lt;/strong&gt;，使得每个线程在某一时间访问到的并非同一个对象，这样就&lt;strong&gt;隔离&lt;/strong&gt;了多个线程对数据的数据共享。&lt;/p&gt;
&lt;p&gt;ThreadLocal和Synchonized都用于解决多线程并发访问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用&lt;strong&gt;锁的机制&lt;/strong&gt;，使变量或代码块在某一时刻仅能被一个线程访问，ThreadLocal则是&lt;strong&gt;副本机制&lt;/strong&gt;，此时不论多少线程并发访问都是线程安全的。&lt;/p&gt;
&lt;p&gt;ThreadLocal最主要的应用场景就是&lt;strong&gt;跨方法进行参数传递&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Web容器中，每个完整的请求周期会由一个线程来处理。ThreadLocal为线程提供变量副本，可以进行事务操作，&lt;strong&gt;存储事务的信息&lt;/strong&gt;；可以&lt;strong&gt;保存数据库连接&lt;/strong&gt;，Spring就是使用一个ThreadLocal来实现“绑定连接到线程”；可以&lt;strong&gt;保存Session会话&lt;/strong&gt;进行管理；在微服务领域，&lt;strong&gt;链路跟踪&lt;/strong&gt;中的traceId传递也是利用了ThreadLocal。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-CompleteableFuture</title>
    <link href="http://example.com/posts/cp-family/5/"/>
    <id>http://example.com/posts/cp-family/5/</id>
    <published>2023-10-06T16:00:00.000Z</published>
    <updated>2023-10-07T15:03:18.119Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CompleteableFuture&quot;&gt;&lt;a href=&quot;#CompleteableFuture&quot; class=&quot;headerlink&quot; title=&quot;CompleteableFuture&quot;&gt;&lt;/a&gt;CompleteableFuture&lt;/h2&gt;&lt;p&gt;JDK1.8才新加入的一个实现类CompletableFuture，实现了Future， CompletionStage两个接口。实现了Future接口，意味着可以通过阻塞或者轮询的方式获得结果。CompletionStage是一个接口，从命名上看得知是一个完成的阶段，它代表了一个特定的计算的阶段，可以同步或者异步的被完成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-等待/通知机制</title>
    <link href="http://example.com/posts/cp-family/4/"/>
    <id>http://example.com/posts/cp-family/4/</id>
    <published>2023-10-05T16:00:00.000Z</published>
    <updated>2023-10-11T09:57:36.463Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;等待-x2F-通知机制&quot;&gt;&lt;a href=&quot;#等待-x2F-通知机制&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-深入学习Java的线程二</title>
    <link href="http://example.com/posts/cp-family/3/"/>
    <id>http://example.com/posts/cp-family/3/</id>
    <published>2023-10-04T16:00:00.000Z</published>
    <updated>2023-10-05T18:30:38.899Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程和协程&quot;&gt;&lt;a href=&quot;#线程和协程&quot; class=&quot;headerlink&quot; title=&quot;线程和协程&quot;&gt;&lt;/a&gt;线程和协程&lt;/h2&gt;&lt;p&gt;线程是操作系统层面的实体，那么Java中的线程怎么和操作系统的线程对应起来？&lt;/p&gt;
&lt;p&gt;任何语言实现线程主要有三种方式：使用内核线程实现（1:1实现)，使用用户线程实现（1:N实现），使用用户线程加轻量级进程混合实现（N:M实现）。Java就是第三种混合实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
