<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park&#39;s Blog</title>
  
  <subtitle>海边微风起，等风也等你</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-04T04:14:11.928Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>忘川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rocket-整合SpringBoot</title>
    <link href="http://example.com/posts/rocket-family/4/"/>
    <id>http://example.com/posts/rocket-family/4/</id>
    <published>2023-12-02T16:00:00.000Z</published>
    <updated>2023-12-04T04:14:11.928Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;SpringBoot整合RocketMQ&quot;&gt;&lt;a href=&quot;#SpringBoot整合RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot整合RocketMQ&quot;&gt;&lt;/a&gt;SpringBoot整合RocketMQ&lt;/h2&gt;&lt;p&gt;创建Maven工程，引入关键依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;rocketmq-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
        &amp;lt;exclusions&amp;gt;
            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.9.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.5.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.5.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Rocket" scheme="http://example.com/tags/Rocket/"/>
    
  </entry>
  
  <entry>
    <title>Rocket-核心编程模型</title>
    <link href="http://example.com/posts/rocket-family/3/"/>
    <id>http://example.com/posts/rocket-family/3/</id>
    <published>2023-11-30T16:00:00.000Z</published>
    <updated>2023-12-03T02:48:41.108Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;RocketMQ的消息模型&quot;&gt;&lt;a href=&quot;#RocketMQ的消息模型&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ的消息模型&quot;&gt;&lt;/a&gt;RocketMQ的消息模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mq/rocket-model.png&quot; alt=&quot;rocket-model&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rocket" scheme="http://example.com/tags/Rocket/"/>
    
  </entry>
  
  <entry>
    <title>Rocket-集群搭建</title>
    <link href="http://example.com/posts/rocket-family/2/"/>
    <id>http://example.com/posts/rocket-family/2/</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2023-12-01T10:48:25.199Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;搭建RocketMQ可视化管理服务&quot;&gt;&lt;a href=&quot;#搭建RocketMQ可视化管理服务&quot; class=&quot;headerlink&quot; title=&quot;搭建RocketMQ可视化管理服务&quot;&gt;&lt;/a&gt;搭建RocketMQ可视化管理服务&lt;/h2&gt;&lt;p&gt;RocketMQ的社区就提供了一个图形化的管理控制台Dashboard，可以用可视化的方式直接观测并管理RocketMQ的运行过程。&lt;/p&gt;
&lt;p&gt;Dashboard服务并不在RocketMQ的运行包中，需要到RocketMQ的官网下载页面单独下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/mq/dashboard.png&quot; alt=&quot;dashboard&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里只提供了源码，并没有提供直接运行的jar包。将源码下载下来后，需要解压并进入对应的目录，使用maven进行编译。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;mvn clean package -Dmaven.test.skip=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;注意：上面的打包命令要在Linux环境下运行，在windows环境下打包报错&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;编译完成后，在源码的target目录下会生成可运行的jar包&lt;code&gt;rocketmq-dashboard-1.0.0.jar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来将这个jar包移动到&lt;code&gt;/app/rocketmq/rocketmq-dashboard&lt;/code&gt;目录下&lt;/p&gt;
&lt;p&gt;在jar包所在的目录下创建一个&lt;code&gt;application.properties&lt;/code&gt;配置文件，在配置文件中做如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;rocketmq.config.namesrvAddr=你的公网IP:9876
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个配置文件中更多的配置选项，可以参考dashboard源码当中的&lt;code&gt;application.properties&lt;/code&gt;配置文件&lt;/p&gt;
&lt;p&gt;应用启动完成后，会在服务器上搭建起一个web服务，我们就可以通过访问&lt;code&gt;http://你的公网IP:8080&lt;/code&gt;查看到管理页面，云服务要在安全组开放8080端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/mq/dashboard-1.png&quot; alt=&quot;dashboard-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rocket" scheme="http://example.com/tags/Rocket/"/>
    
  </entry>
  
  <entry>
    <title>Rocket-快速实战</title>
    <link href="http://example.com/posts/rocket-family/1/"/>
    <id>http://example.com/posts/rocket-family/1/</id>
    <published>2023-11-28T16:00:00.000Z</published>
    <updated>2023-11-30T15:16:54.473Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;MQ简介&quot;&gt;&lt;a href=&quot;#MQ简介&quot; class=&quot;headerlink&quot; title=&quot;MQ简介&quot;&gt;&lt;/a&gt;MQ简介&lt;/h2&gt;&lt;p&gt;MQ：MessageQueue，消息队列。是在互联网中使用非常广泛的一系列服务中间件。&lt;/p&gt;
&lt;p&gt;Message：消息。消息是在&lt;font color=&quot;red&quot;&gt;不同进程之间传递的数据&lt;/font&gt;。这些进程可以部署在同一台机器上，也可以分布在不同机器上。（数据形式：二进制压缩数据、RPC、http，都属于进程间通讯的机制）&lt;/p&gt;
&lt;p&gt;Queue：队列。队列原意是指一种具有FIFO(先进先出)特性的数据结构，是用来缓存数据的。对于消息中间件产品来说，能不能保证FIFO特性，尚值得考量。但是，所有消息队列都是需要具备&lt;font color=&quot;red&quot;&gt;存储消息&lt;/font&gt;，让消息排队的能力。&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步，&lt;font color=&quot;red&quot;&gt;提高系统的响应速度、吞吐量。&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;解耦，减少服务之间的影响。提高系统整体的&lt;font color=&quot;red&quot;&gt;稳定性以及可扩展性。&lt;/font&gt;另外，解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行消费，并且消费者的增加或者减少对生产者没有影响。&lt;/li&gt;
&lt;li&gt;消峰，&lt;font color=&quot;red&quot;&gt;以稳定的系统资源应对突发的流量冲击。&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Rocket" scheme="http://example.com/tags/Rocket/"/>
    
  </entry>
  
  <entry>
    <title>Redis-性能优化</title>
    <link href="http://example.com/posts/redis-family/7/"/>
    <id>http://example.com/posts/redis-family/7/</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-27T11:03:08.368Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;Redis缓存设计&quot;&gt;&lt;a href=&quot;#Redis缓存设计&quot; class=&quot;headerlink&quot; title=&quot;Redis缓存设计&quot;&gt;&lt;/a&gt;Redis缓存设计&lt;/h2&gt;&lt;h3 id=&quot;缓存与数据库双写不一致&quot;&gt;&lt;a href=&quot;#缓存与数据库双写不一致&quot;</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-缓存高可用集群</title>
    <link href="http://example.com/posts/redis-family/6/"/>
    <id>http://example.com/posts/redis-family/6/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2023-11-26T02:46:08.896Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;Redis缓存设计&quot;&gt;&lt;a href=&quot;#Redis缓存设计&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-缓存高可用集群</title>
    <link href="http://example.com/posts/redis-family/5/"/>
    <id>http://example.com/posts/redis-family/5/</id>
    <published>2023-11-23T16:00:00.000Z</published>
    <updated>2023-11-24T15:42:32.380Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;Redis集群方案比较&quot;&gt;&lt;a href=&quot;#Redis集群方案比较&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-主从与哨兵架构</title>
    <link href="http://example.com/posts/redis-family/4/"/>
    <id>http://example.com/posts/redis-family/4/</id>
    <published>2023-11-22T16:00:00.000Z</published>
    <updated>2023-11-23T17:15:44.938Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Jedis使用&quot;&gt;&lt;a href=&quot;#Jedis使用&quot; class=&quot;headerlink&quot; title=&quot;Jedis使用&quot;&gt;&lt;/a&gt;Jedis使用&lt;/h2&gt;&lt;h4 id=&quot;Jedis连接代码示例：&quot;&gt;&lt;a href=&quot;#Jedis连接代码示例：&quot; class=&quot;headerlink&quot; title=&quot;Jedis连接代码示例：&quot;&gt;&lt;/a&gt;Jedis连接代码示例：&lt;/h4&gt;&lt;p&gt;1、引入依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、访问代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class JedisSingleTest
{
    public static void main(String[] args)
    {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(20);
        jedisPoolConfig.setMaxIdle(10);
        jedisPoolConfig.setMinIdle(5);
        
        // timeout，这里既是连接超时又是读写超时，从Jedis 2.8开始有区分connectionTimeout和soTimeout的构造函数
        JedisPool jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.0.4&quot;, 6379, 3000, null);
        
        Jedis jedis = jedisPool.getResource();
        System.out.println(jedis.set(&quot;single&quot;, &quot;gc&quot;));  // OK
        System.out.println(jedis.get(&quot;single&quot;));		// gc
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：如果是购买的云服务器，需要在安全组添加端口规则&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-持久化</title>
    <link href="http://example.com/posts/redis-family/3/"/>
    <id>http://example.com/posts/redis-family/3/</id>
    <published>2023-11-21T16:00:00.000Z</published>
    <updated>2023-11-22T15:11:58.548Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;h3 id=&quot;RDB快照（snapshot）&quot;&gt;&lt;a href=&quot;#RDB快照（snapshot）&quot; class=&quot;headerlink&quot; title=&quot;RDB快照（snapshot）&quot;&gt;&lt;/a&gt;RDB快照（snapshot）&lt;/h3&gt;&lt;p&gt;Redis 的内存数据库快照默认保存在 &lt;code&gt;dump.rdb&lt;/code&gt; 二进制文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis.conf&lt;/code&gt;配置文件描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;# Save the DB to disk.
#
# save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; [&amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; ...]
#
# Redis will save the DB if the given number of seconds elapsed and it
# surpassed the given number of write operations against the DB.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save &quot;&quot;
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 change was performed
#   * After 300 seconds (5 minutes) if at least 100 changes were performed
#   * After 60 seconds if at least 10000 changes were performed
#
# You can set these explicitly by uncommenting the following line.
#
# save 3600 1 300 100 60 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成RDB快照命令：&lt;strong&gt;save&lt;/strong&gt;或&lt;strong&gt;bgsave&lt;/strong&gt;（redis客户端执行命令，每次执行生成新的rdb文件，覆盖原有的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bgsave的写时复制(COW)机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 &lt;font color=&quot;red&quot;&gt;fork 生成&lt;/font&gt;的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;save与bgsave对比：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;save&lt;/th&gt;
&lt;th&gt;bgsave&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;IO类型&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是否阻塞redis其它命令&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否（在生成子进程调用fork函数时会有短暂阻塞）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复杂度&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;不会消耗额外内存&lt;/td&gt;
&lt;td&gt;不阻塞客户端命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺点&lt;/td&gt;
&lt;td&gt;阻塞客户端命令&lt;/td&gt;
&lt;td&gt;需要fork子进程，消耗内存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; &lt;font color=&quot;red&quot;&gt;配置自动生成rdb文件后台使用的是bgsave方式&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-五种数据类型</title>
    <link href="http://example.com/posts/redis-family/2/"/>
    <id>http://example.com/posts/redis-family/2/</id>
    <published>2023-11-20T16:00:00.000Z</published>
    <updated>2023-11-21T16:29:09.168Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis基本特性&quot;&gt;&lt;a href=&quot;#Redis基本特性&quot; class=&quot;headerlink&quot; title=&quot;Redis基本特性&quot;&gt;&lt;/a&gt;&lt;code&gt;Redis&lt;/code&gt;基本特性&lt;/h2&gt;&lt;p&gt;a) 非关系型的&lt;font color=&quot;red&quot;&gt;键值对&lt;/font&gt;数据库，可以根据键以O(1) 的时间复杂度取出或插入关联值&lt;/p&gt;
&lt;p&gt;b) &lt;code&gt;Redis&lt;/code&gt; 的数据是存在&lt;font color=&quot;red&quot;&gt;内存&lt;/font&gt;中的&lt;/p&gt;
&lt;p&gt;c) 键值对中键的类型可以是字符串，整型，浮点型等，且键是唯一的&lt;/p&gt;
&lt;p&gt;d) 键值对中的值类型可以是string，hash，list，set，sorted set 等&lt;/p&gt;
&lt;p&gt;e) &lt;code&gt;Redis&lt;/code&gt; 内置了复制，磁盘持久化，&lt;code&gt;LUA&lt;/code&gt;脚本，事务，&lt;font color=&quot;orange&quot;&gt;SSL,  ACLs，客户端缓存，客户端代理等功能（6.0新特性）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;f) 通过&lt;code&gt;Redis&lt;/code&gt; 哨兵和&lt;code&gt;Redis Cluster&lt;/code&gt; 模式提供高可用性&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-核心数据结构</title>
    <link href="http://example.com/posts/redis-family/1/"/>
    <id>http://example.com/posts/redis-family/1/</id>
    <published>2023-11-19T16:00:00.000Z</published>
    <updated>2023-11-20T16:32:50.617Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis安装&quot;&gt;&lt;a href=&quot;#Redis安装&quot; class=&quot;headerlink&quot; title=&quot;Redis安装&quot;&gt;&lt;/a&gt;Redis安装&lt;/h2&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://redis.io/download&quot;&gt;http://redis.io/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;# 1、安装gcc
apt-get install gcc
    
# 2、下载redis-7.0.3.tar.gz并解压
wget http://download.redis.io/releases/redis-7.0.3.tar.gz
tar xzf redis-7.0.3.tar.gz
cd redis-7.0.3

# 3、进入到解压好的redis‐7.0.3目录下，进行编译与安装
make
    
# 4、修改配置
daemonize yes #后台启动
protected‐mode no #关闭保护模式，开启的话，只有本机才可以访问redis

# 4.5、需要注释掉bind
# bind 127.0.0.1 -::1

# 5、启动服务
src/redis‐server redis.conf
    
# 6、验证启动是否成功
ps ‐ef | grep redis
    
# 7、进入redis客户端
src/redis‐cli
    
# 8、退出客户端
quit
    
# 9、退出redis服务：（亲测三种都可用）
（1）pkill redis‐server
（2）kill 进程号
（3）src/redis‐cli shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里原计划是安装&lt;code&gt;redis-5.0.3.tar.gz&lt;/code&gt;版本，但是安装解压后执行make命令时一直报错&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;错误信息：&lt;code&gt;collect2.exe: error: ld returned 1 exit status&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;collect2 error ld returned 1 exit status提示出现之前，一般在上面几行都会有其他报错，而collect2 error ld returned 1 exit status所反映的只是其之前一共出现了多少个错误，真正的错误是在其上面出现的那些报错。比如，没有错误，会提示collect2 error ld returned 0 exit status；有两个报错，会提示collect2 error ld returned 2 exit status。所以，真正要解决的是在collect2 error ld returned 1 exit status提示出现之前的那些报错提醒&lt;br&gt;解决问题思路参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_45055622/article/details/126634000&quot;&gt;https://blog.csdn.net/weixin_45055622/article/details/126634000&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尝试过网上给出的多种方案，包括：&lt;/p&gt;
&lt;p&gt;1、添加配置&lt;code&gt;OPT=-O2 -march=i686&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、使用&lt;code&gt;make MALLOC=libc&lt;/code&gt;命令替换make&lt;/p&gt;
&lt;p&gt;3、删除解压包，重新安装&lt;/p&gt;
&lt;p&gt;然而都没有解决问题，最后切换安装版本为&lt;code&gt;redis-7.0.3.tar.gz&lt;/code&gt;解决问题，其他版本未测试&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring-ProxyFactory</title>
    <link href="http://example.com/posts/spring-family/11/"/>
    <id>http://example.com/posts/spring-family/11/</id>
    <published>2023-11-11T16:00:00.000Z</published>
    <updated>2023-11-12T16:46:49.433Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;a href=&quot;#ProxyFactory选择cglib或jdk动态代理原理&quot; class=&quot;headerlink&quot; title=&quot;ProxyFactory选择cglib或jdk动态代理原理&quot;&gt;&lt;/a&gt;ProxyFactory选择cglib或jdk动态代理原理&lt;/h2&gt;&lt;p&gt;ProxyFactory在生成代理对象之前需要决定是使用JDK动态代理还是CGLIB技术：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

    @Override
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        // 如果ProxyFactory的isOptimize为true，Spring认为cglib比jdk动态代理要快
        // 或者isProxyTargetClass为true，
        // 或者被代理对象没有实现接口，
        // 或者只实现了SpringProxy这个接口
        // 那么则利用Cglib进行动态代理，但如果被代理类是接口，或者被代理类已经是进行过JDK动态代理而生成的代理类了则只能进行JDK动态代理

        // 其他情况都会进行JDK动态代理，比如被代理类实现了除SpringProxy接口之外的其他接口

        // 是不是在GraalVM虚拟机上运行
        if (!NativeDetector.inNativeImage() &amp;amp;&amp;amp;
                (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
            // config就是ProxyFactory对象
            Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                        &quot;Either an interface or a target is required for proxy creation.&quot;);
            }
            // targetClass是接口，直接使用Jdk动态代理
            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
                return new JdkDynamicAopProxy(config);
            }
            // 使用Cglib
            return new ObjenesisCglibAopProxy(config);
        }
        else {
            // 使用Jdk动态代理
            return new JdkDynamicAopProxy(config);
        }
    }

    /**
     * Determine whether the supplied {@link AdvisedSupport} has only the
     * {@link org.springframework.aop.SpringProxy} interface specified
     * (or no proxy interfaces specified at all).
     */
    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class&amp;lt;?&amp;gt;[] ifcs = config.getProxiedInterfaces();
        return (ifcs.length == 0 || (ifcs.length == 1 &amp;amp;&amp;amp; SpringProxy.class.isAssignableFrom(ifcs[0])));
    }
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-SpringAOP的实现</title>
    <link href="http://example.com/posts/spring-family/10/"/>
    <id>http://example.com/posts/spring-family/10/</id>
    <published>2023-11-10T16:00:00.000Z</published>
    <updated>2023-11-12T16:59:47.229Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对Spring-AOP的理解&quot;&gt;&lt;a href=&quot;#对Spring-AOP的理解&quot; class=&quot;headerlink&quot; title=&quot;对Spring AOP的理解&quot;&gt;&lt;/a&gt;对Spring AOP的理解&lt;/h2&gt;&lt;p&gt;OOP表示面向对象编程，是一种编程思想，AOP表示面向切面编程，也是一种编程思想&lt;/p&gt;
&lt;p&gt;Spring AOP：Spring为了让程序员更加方便的做到面向切面编程所提供的技术支持&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;Spring提供的一套机制，让我们更容易的进行AOP，这套机制就是Spring AOP&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;扩展：用注解的方式来定义Pointcut和Advice，Spring并不是首创，首创是 AspectJ。JBoss 4.0、aspectwerkz 等技术也提供了对于AOP的支持。&lt;/p&gt;
&lt;p&gt;Spring是依赖了AspectJ的，Spring觉得AspectJ中的@Before、@Around等注解比较好用，所以把这些注解直接拿过来用，但是注解底层的解析是由Spring自己做的。&lt;/p&gt;
&lt;p&gt;所以我们在用 Spring时，如果你想用@Before、@Around等注解，是需要单独引入aspecj相关jar包的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;compile group: &#39;org.aspectj&#39;, name: &#39;aspectjrt&#39;, version: &#39;1.9.5&#39;
compile group: &#39;org.aspectj&#39;, name: &#39;aspectjweaver&#39;, version: &#39;1.9.5&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：AspectJ（它自己也是一个项目）是在编译时对字节码进行了修改，可以理解为是在&lt;strong&gt;编译时就会去解析&lt;/strong&gt;@Before这些注解，然后得到代理逻辑，加入到被代理类的字节码中去，所以如果想用AspectJ技术来生成代理对象 ，是需要用单独的AspectJ编译器的。项目中很少用AspectJ编译器，只是用了@Before这些注解，在&lt;strong&gt;启动Spring的过程中&lt;/strong&gt;会去解析这些注解，然后利用动态代理机制生成代理对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-动态代理</title>
    <link href="http://example.com/posts/spring-family/9/"/>
    <id>http://example.com/posts/spring-family/9/</id>
    <published>2023-11-09T16:00:00.000Z</published>
    <updated>2023-11-10T15:51:24.602Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;代理模式：为其他对象提供一种代理以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。&lt;/p&gt;
&lt;p&gt;动态代理可以在&lt;strong&gt;不修改类源码&lt;/strong&gt;的前提下，给类中方法增加额外逻辑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过cglib来实现的代理对象的创建：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;基于&lt;strong&gt;父子类&lt;/strong&gt;，被代理类是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由cglib创建的&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-推断构造方法</title>
    <link href="http://example.com/posts/spring-family/8/"/>
    <id>http://example.com/posts/spring-family/8/</id>
    <published>2023-11-08T16:00:00.000Z</published>
    <updated>2023-11-12T17:07:52.979Z</updated>
    
    
    <summary type="html">&lt;p&gt;Spring中的Bean实例化对象，需要构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常一个类只有一个构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、无参的构造方法，实例化只能选择这一个&lt;/p&gt;
&lt;p&gt;2、有参的构造方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，Spring根据构造方法的参数信息去寻找Bean，然后传给构造方法&lt;/li&gt;
&lt;li&gt;使用ClassPathXmlApplicationContext，表示使用XML的方式来使用bean。在XML中指定手动指定构造方法的参数值；或者配置autowire=constructor让Spring自动去寻找bean做为构造方法参数值。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-循环依赖简述</title>
    <link href="http://example.com/posts/spring-family/7/"/>
    <id>http://example.com/posts/spring-family/7/</id>
    <published>2023-11-07T16:00:00.000Z</published>
    <updated>2023-11-08T15:54:06.169Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;// A依赖了B
class A
{
    public B b;
}

// B依赖了A
class B
{
    public A a;
}

// 循环依赖
A a = new A();
B b = new B();
a.b = b;
b.a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象之间的相互依赖很正常，但是在Spring中由于对象创建要经过Bean的生命周期，所以就有了循环依赖问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入二</title>
    <link href="http://example.com/posts/spring-family/6/"/>
    <id>http://example.com/posts/spring-family/6/</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-08T03:05:47.615Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;findAutowireCandidates-实现&quot;&gt;&lt;a href=&quot;#findAutowireCandidates-实现&quot; class=&quot;headerlink&quot; title=&quot;findAutowireCandidates()实现&quot;&gt;&lt;/a&gt;findAutowireCandidates()实现&lt;/h2&gt;&lt;p&gt;1、找出BeanFactory中类型为type的所有的Bean的名字，根据BeanDefinition就能判断和当前type是不是匹配，不用生成Bean对象&lt;/p&gt;
&lt;p&gt;2、把resolvableDependencies中key为type的对象找出来并添加到result中&lt;/p&gt;
&lt;p&gt;3、遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入&lt;/p&gt;
&lt;p&gt;4、先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断&lt;/p&gt;
&lt;p&gt;5、判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断&lt;/p&gt;
&lt;p&gt;6、如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配&lt;/p&gt;
&lt;p&gt;7、经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-依赖注入</title>
    <link href="http://example.com/posts/spring-family/5/"/>
    <id>http://example.com/posts/spring-family/5/</id>
    <published>2023-11-04T16:00:00.000Z</published>
    <updated>2023-11-06T15:27:12.591Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;a href=&quot;#Spring中到底有几种依赖注入的方式？&quot; class=&quot;headerlink&quot; title=&quot;Spring中到底有几种依赖注入的方式？&quot;&gt;&lt;/a&gt;Spring中到底有几种依赖注入的方式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动注入&lt;/p&gt;
&lt;p&gt;a）set方式注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b）构造方法注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&amp;lt;bean name=&quot;userService&quot; class=&quot;com.gax.service.UserService&quot;&amp;gt;
    &amp;lt;constructor‐arg index=&quot;0&quot; ref=&quot;orderService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动注入&lt;/p&gt;
&lt;p&gt;a）XML的autowire自动注入&lt;/p&gt;
&lt;p&gt;b） @Autowired注解的自动注入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean生命周期源码</title>
    <link href="http://example.com/posts/spring-family/4/"/>
    <id>http://example.com/posts/spring-family/4/</id>
    <published>2023-10-28T16:00:00.000Z</published>
    <updated>2023-11-12T16:50:24.940Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Bean的生成过程&quot;&gt;&lt;a href=&quot;#Bean的生成过程&quot; class=&quot;headerlink&quot; title=&quot;Bean的生成过程&quot;&gt;&lt;/a&gt;Bean的生成过程&lt;/h2&gt;&lt;p&gt;首先看创建一个Spring容器的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

源码：
/**
 * Create a new AnnotationConfigApplicationContext that needs to be populated
 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
 */
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&quot;spring.context.annotated-bean-reader.create&quot;);
    // 额外会创建StandardEnvironment
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-底层架构核心概念</title>
    <link href="http://example.com/posts/spring-family/3/"/>
    <id>http://example.com/posts/spring-family/3/</id>
    <published>2023-10-26T16:00:00.000Z</published>
    <updated>2023-11-12T17:10:14.206Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring底层核心组件&quot;&gt;&lt;a href=&quot;#Spring底层核心组件&quot; class=&quot;headerlink&quot; title=&quot;Spring底层核心组件&quot;&gt;&lt;/a&gt;Spring底层核心组件&lt;/h2&gt;&lt;h3 id=&quot;BeanDefinition&quot;&gt;&lt;a href=&quot;#BeanDefinition&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition&quot;&gt;&lt;/a&gt;BeanDefinition&lt;/h3&gt;&lt;p&gt;BeanDefinition表示Bean定义，有很多属性用来描述Bean的特点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class，表示Bean类型 &lt;/li&gt;
&lt;li&gt;scope，表示Bean作用域，单例或原型等 &lt;/li&gt;
&lt;li&gt;lazyInit：表示Bean是否是懒加载 &lt;/li&gt;
&lt;li&gt;initMethodName：表示Bean初始化时要执行的方法 &lt;/li&gt;
&lt;li&gt;destroyMethodName：表示Bean销毁时要执行的方法 &lt;/li&gt;
&lt;li&gt;还有很多…&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
</feed>
