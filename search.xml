<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL-索引优化实践</title>
      <link href="/posts/mysql-family/3/"/>
      <url>/posts/mysql-family/3/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引优化实践"><a href="#MySQL-索引优化实践" class="headerlink" title="MySQL-索引优化实践"></a>MySQL-索引优化实践</h1><p>预置表数据：</p><pre class=" language-java"><code class="language-java">CREATE TABLE `employees` <span class="token punctuation">(</span>    `id` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>    `name` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">24</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'姓名'</span><span class="token punctuation">,</span>    `age` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">'0'</span> COMMENT <span class="token string">'年龄'</span><span class="token punctuation">,</span>    `position` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'职位'</span><span class="token punctuation">,</span>    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="token string">'入职时间'</span><span class="token punctuation">,</span>    PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span> `id` <span class="token punctuation">)</span><span class="token punctuation">,</span>    KEY `idx_name_age_position` <span class="token punctuation">(</span> `name`<span class="token punctuation">,</span> `age`<span class="token punctuation">,</span> `position` <span class="token punctuation">)</span> USING BTREE <span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> INNODB AUTO_INCREMENT <span class="token operator">=</span> <span class="token number">4</span> DEFAULT CHARSET <span class="token operator">=</span> utf8 COMMENT <span class="token operator">=</span> <span class="token string">'员工记录表'</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'LiLei'</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'manager'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'HanMeimei'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>1. 全值匹配</strong></p><p>查询条件 = 确切的值</p><p><img src="/images/mysql/idx-1.png" alt="idx-1"></p><p><img src="/images/mysql/idx-2.png" alt="idx-2"></p><p><img src="/images/mysql/idx-3.png" alt="idx-3"></p><p>根据key_len计算规则：</p><p>字符串类型varchar(n)：如果存汉字则长度是 3n + 2 字节</p><p>数值类型int：4字节</p><p>name：<code>24*3+2 = 74</code>字节，age：<code>4</code>字节，position：<code>20*3+2 = 62</code>字节</p><p><strong>2. 最左前缀法则</strong></p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p><img src="/images/mysql/idx-4.png" alt="idx-4"></p><p><img src="/images/mysql/idx-5.png" alt="idx-5"></p><p><img src="/images/mysql/idx-6.png" alt="idx-6"></p><p>总结：查询1满足最左前列法则可以使用索引，查询2和3跳过索引中的列查询导致索引失效</p><p><strong>3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></p><p><img src="/images/mysql/idx-7.png" alt="idx-7"></p><p><img src="/images/mysql/idx-8.png" alt="idx-8"></p><p>转化为日期范围查询，有可能会走索引：</p><p><img src="/images/mysql/idx-9.png" alt="idx-9"></p><p>总结：查询语句是否走索引和索引的结构息息相关，<strong>排好序</strong></p><p><strong>4. 存储引擎不能使用索引中范围条件右边的列</strong></p><p><img src="/images/mysql/idx-10.png" alt="idx-10"></p><p><strong>5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong></p><p><img src="/images/mysql/idx-11.png" alt="idx-11"></p><p><strong>6. MySQL在使用不等于（!=或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描 &lt; 小于、 &gt; 大于、 &lt;=、&gt;= 这些，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</strong></p><p><img src="/images/mysql/idx-12.png" alt="idx-12"></p><p><strong>7. is null,is not null 一般情况下也无法使用索引</strong></p><p><img src="/images/mysql/idx-13.png" alt="idx-13"></p><p><strong>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong></p><p><img src="/images/mysql/idx-14.png" alt="idx-14"></p><p><img src="/images/mysql/idx-15.png" alt="idx-15"></p><p>问题：解决like’%字符串%’索引不被使用的方法？ </p><p>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p><p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p><p><strong>9. 字符串不加单引号索引失效</strong></p><p><img src="/images/mysql/idx-16.png" alt="idx-16"></p><p><strong>10. 少用or或in，用它查询时，MySQL不一定使用索引，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估 是否使用索引，详见范围查询优化</strong></p><p><img src="/images/mysql/idx-17.png" alt="idx-17"></p><p><strong>11. 范围查询优化</strong></p><p><img src="/images/mysql/idx-18.png" alt="idx-18"></p><p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由 于单次数据量查询过大导致优化器最终选择不走索引 优化方法：可以将大的范围拆分成多个小范围</p><p><img src="/images/mysql/idx-19.png" alt="idx-19"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-Explain</title>
      <link href="/posts/mysql-family/2/"/>
      <url>/posts/mysql-family/2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-Explain"><a href="#MySQL-Explain" class="headerlink" title="MySQL-Explain"></a>MySQL-Explain</h1><h4 id="Explain工具是什么？"><a href="#Explain工具是什么？" class="headerlink" title="Explain工具是什么？"></a>Explain工具是什么？</h4><p>是MySQL提供的工具，在select前添加explain关键字，会返回执行计划信息，而不是执行SQL</p><p>可以用来分析SQL的执行情况，比如使用哪些索引，扫描哪些行…</p><p>注意：如果from包含子查询，仍会执行该子查询，查询结果放入到临时表中</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">Explain官网入口</a></p><span id="more"></span><p>辅助学习理解预置表数据：</p><pre class=" language-java"><code class="language-java">DROP TABLE IF EXISTS `actor`<span class="token punctuation">;</span>CREATE TABLE `actor` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`name` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>`update_time` datetime DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `actor` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `name`<span class="token punctuation">,</span> `update_time`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DROP TABLE IF EXISTS `film`<span class="token punctuation">;</span>CREATE TABLE `film` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>`name` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>KEY `idx_name` <span class="token punctuation">(</span>`name`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `film` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `name`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'film0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'film1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'film2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DROP TABLE IF EXISTS `film_actor`<span class="token punctuation">;</span>CREATE TABLE `film_actor` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`film_id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`actor_id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`remark` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>KEY `idx_film_actor_id` <span class="token punctuation">(</span>`film_id`<span class="token punctuation">,</span>`actor_id`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `film_actor` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `film_id`<span class="token punctuation">,</span> `actor_id`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Explain怎么用？"><a href="#Explain怎么用？" class="headerlink" title="Explain怎么用？"></a>Explain怎么用？</h4><p>在select查询语句前面加上<code>explain</code>关键字即可，sql语句中每有一个select关键字就会输出一行类似执行计划的信息</p><p><img src="/images/mysql/explain-1.png" alt="explain-1"></p><p><img src="/images/mysql/explain-2.png" alt="explain-2"></p><p><strong>explain 两个变种</strong></p><p>a) <strong>explain extended</strong>：额外提供一些优化信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表，id值越大执行的优先级越高，id相同从上往下执行，注意这里的id并非主键）</p><p>b) <strong>explain partitions</strong>：多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分 区</p><p>我的MySQL5.7版本添加explain默认展示了filtered 和partitions 列，extended和partitions关键字未来版本可能会被移除</p><p>explain输出结果每一列的含义，截取官网描述如下：</p><p><strong>Table 8.1 EXPLAIN Output Columns</strong></p><table><thead><tr><th align="left">Column</th><th align="left">JSON Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id"><code>id</code></a></td><td align="left"><code>select_id</code></td><td align="left">The <code>SELECT</code> identifier</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type"><code>select_type</code></a></td><td align="left">None</td><td align="left">The <code>SELECT</code> type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table"><code>table</code></a></td><td align="left"><code>table_name</code></td><td align="left">The table for the output row</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions"><code>partitions</code></a></td><td align="left"><code>partitions</code></td><td align="left">The matching partitions</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type"><code>type</code></a></td><td align="left"><code>access_type</code></td><td align="left">The join type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td><td align="left"><code>possible_keys</code></td><td align="left">The possible indexes to choose</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key"><code>key</code></a></td><td align="left"><code>key</code></td><td align="left">The index actually chosen</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len"><code>key_len</code></a></td><td align="left"><code>key_length</code></td><td align="left">The length of the chosen key</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref"><code>ref</code></a></td><td align="left"><code>ref</code></td><td align="left">The columns compared to the index</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows"><code>rows</code></a></td><td align="left"><code>rows</code></td><td align="left">Estimate of rows to be examined</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered"><code>filtered</code></a></td><td align="left"><code>filtered</code></td><td align="left">Percentage of rows filtered by table condition</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra"><code>Extra</code></a></td><td align="left">None</td><td align="left">Additional information</td></tr></tbody></table><p><strong>explain中的列详细介绍</strong> </p><p><strong>1. id列</strong> </p><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><p><strong>2. select_type列</strong></p><p> select_type 表示对应行是简单还是复杂的查询。</p><p><img src="/images/mysql/explain-3.png" alt="explain-3"></p><p>1）simple：简单查询。查询不包含子查询和union </p><p>2）primary：复杂查询中最外层的 select </p><p>3）subquery：包含在 select 中的子查询（不在 from 子句中） </p><p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表</p><p>5）union：在 union 中的第二个和随后的 select</p><p><img src="/images/mysql/explain-4.png" alt="explain-4"></p><p><strong>3. table列</strong> </p><p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是<code>&lt;derivenN&gt;</code>格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 当有 union 时，UNION RESULT 的 table 列的值为<code>&lt;union1,2&gt;</code>，1和2表示参与 union 的 select 行id。</p><p><strong>4. partitions列</strong> </p><p>如果查询是基于分区表的话，partitions 字段会显示查询将访问的分区。</p><p><strong>5. type列</strong> </p><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p><p>依次从最优到最差分别为：<font color="red">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</font> </p><p>一般来说，<font color="red">得保证查询达到range级别，最好达到ref </font></p><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表（目标数据在主键索引树和二级索引树同时存在时，优先用二级索引树去查，因为二级索引树没有保存全部数据，更轻量效率高）</p><p><img src="/images/mysql/explain-5.png" alt="explain-5"></p><p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量。用于 primary key 或 unique key 的所有列与常数比较时，所有表最多有一个匹配行，读取1次速度比较快。</p><p><strong>system是 const的特例</strong>，表里只有一条记录匹配时为system</p><p><img src="/images/mysql/explain-6.png" alt="explain-6"></p><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p><p><img src="/images/mysql/explain-7.png" alt="explain-7"></p><p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><p>简单 select 查询，name是普通索引（非唯一索引）：</p><p><img src="/images/mysql/explain-8.png" alt="explain-8"></p><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分：</p><p><img src="/images/mysql/explain-9.png" alt="explain-9"></p><p><strong>range</strong>：范围扫描通常出现在 <code>in(), between ,&gt; ,&lt;, &gt;=</code> 等操作中。使用一个索引来检索给定范围的行。</p><p><img src="/images/mysql/explain-10.png" alt="explain-10"></p><p><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</p><p><img src="/images/mysql/explain-11.png" alt="explain-11"></p><p><strong>ALL</strong>：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化。</p><p><img src="/images/mysql/explain-12.png" alt="explain-12"></p><p><strong>6. possible_keys列</strong></p><p>这一列显示查询可能使用哪些索引来查找。 </p><p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </p><p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p><p> <strong>7.key列</strong> </p><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><p><strong>8.key_len列</strong> </p><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p><p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><p><img src="/images/mysql/explain-13.png" alt="explain-13"></p><p>key_len计算规则如下： </p><ul><li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数</strong>，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节 </p></li><li><ul><li>char(n)：如果存汉字长度就是 3n 字节</li></ul></li><li><ul><li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</li></ul></li><li><p>数值类型 </p></li><li><ul><li>tinyint：1字节 </li><li>smallint：2字节 </li><li>int：4字节 </li><li>bigint：8字节</li></ul></li></ul><p>　</p><ul><li><p>时间类型　 </p></li><li><ul><li>date：3字节 </li><li>timestamp：4字节</li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索 引。</p><p><strong>9. ref列</strong> </p><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p><p><strong>10. rows列</strong> </p><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </p><p><strong>11.filtered 列</strong> </p><p>该列是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p><p><strong>12. Extra列</strong> </p><p>这一列展示的是额外信息。常见的重要值如下： </p><p>1）<strong>Using index：</strong>使用覆盖索引 </p><p>覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p><p><img src="/images/mysql/explain-14.png" alt="explain-14"></p><p>2）<strong>Using where：</strong>使用 where 语句来处理结果，并且查询的列未被索引覆盖</p><p><img src="/images/mysql/explain-15.png" alt="explain-15"></p><p>3）<strong>Using index condition：</strong>查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p><p><img src="/images/mysql/explain-16.png" alt="explain-16"></p><p>4）<strong>Using temporary：</strong>mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ol><li><p>actor.name没有索引，此时创建了张临时表来distinct</p><p><img src="/images/mysql/explain-17.png" alt="explain-17"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</p><p><img src="/images/mysql/explain-18.png" alt="explain-18"></p></li></ol><p>5）<strong>Using filesort：</strong>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p><p><img src="/images/mysql/explain-19.png" alt="explain-19"></p></li><li><p>film.name建立了idx_name索引,此时查询时extra是using index</p><p><img src="/images/mysql/explain-20.png" alt="explain-20"></p></li></ol><p>6）<strong>Select tables optimized away：</strong>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</p><p><img src="/images/mysql/explain-21.png" alt="explain-21"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引篇</title>
      <link href="/posts/mysql-family/1/"/>
      <url>/posts/mysql-family/1/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL-索引"></a>MySQL-索引</h1><h4 id="为什么要学习MySQL？"><a href="#为什么要学习MySQL？" class="headerlink" title="为什么要学习MySQL？"></a>为什么要学习MySQL？</h4><p>目前互联网公司多数都在使用，MySQL的数据结构和一些设计思想很值得学习，面试必问…</p><p>思考：生产上遇到的慢查询/慢SQL查询，解决方法通常是添加索引，添加索引后查询速度可以提升几个数量级怎么做到的？正常一条SQL执行速度是几十毫秒或者几百毫秒，慢SQL执行几秒甚至几十秒肯定是不合理的。</p><p>想要学好MySQL首先要理解<code>索引</code>的概念，索引可以帮助MySQL高效查找数据，是一个<font color="red">排好序</font>的<font color="red">数据结构</font>（排好序体现在从左到右依次递增）。</p><p>国外的一个数据结构图示化网址：<a href="https://www.cs.usfca.edu/~galles/visualization/">https://www.cs.usfca.edu/~galles/visualization/</a></p><span id="more"></span><h4 id="索引的数据结构有很多："><a href="#索引的数据结构有很多：" class="headerlink" title="索引的数据结构有很多："></a>索引的数据结构有很多：</h4><ul><li>二叉树</li></ul><p>也叫折半查找，可以快速定位到数据。特点是右子节点的数据一定大于父节点的数据，左子节点的数据一定小于父节点的数据。缺点是由于每个节点只保存单个数据，所以数据量越大树的高度就会越高，查询次数越多查询效率会变低，极端情况例如所有数据都在节点的同一侧，查询类似逐行查找效率很低。</p><p><img src="/images/mysql/BinarySearchTree.png" alt="Binary Search Tree"></p><ul><li>红黑树</li></ul><p>也叫二叉平衡树，在二叉树的基础上做了优化。当节点左右两侧树的高度相差较多时自动做平衡，可以提高一定的查询性能，同时在平衡过程中会带来一定的消耗（左旋右旋等）。数据量大时，同样有树的高度变高导致查询次数多而效率低的问题。Hashmap在1.8版本做了优化，数据结构改为数组＋链表和红黑树，后续再做详细总结。</p><p><img src="/images/mysql/RedBlackTree.png" alt="Red/Black Tree"></p><ul><li>hash</li></ul><p>对于等值查询支持良好，不支持范围查找。对索引键做hash运算后维护到hash表（hash表中保存磁盘文件的地址）中，并关联到数据在磁盘中的地址，可以一次快速查找到目标数据。MySQL实现了自己的hash算法（常见的MD5、CRC16、CRC32等都是hash算法），发生hash冲突时数据在hash桶后面追加。</p><ul><li>B-树</li></ul><p>思考：在红黑树的基础上，横向保存的节点越多，是不是就意味着树的高度越低？</p><p>单个节点可以保存更多的数据。数据量大时，可以明显的降低树的高度，减少查询次数从而提高性能。</p><p>特点：叶子节点具有相同的深度，且指针为空；所有索引元素不重复；节点的数据索引左到右依次递增。</p><p><img src="/images/mysql/BTrees.png" alt="B Trees"></p><p>MySQL的B-树：</p><p><img src="/images/mysql/MySQLBTree.png" alt="MySQL B Trees"></p><ul><li>B+树</li></ul><p>MySQL索引没有选择纯粹的B-树，而是对其进行优化，使用B＋树（B-树变种）作为底层的数据结构，B＋树这种数据结构数据量越大性能提升的越明显。</p><p>B＋树的叶子节点（磁盘页）保存着多条索引和数据，把每个叶子节点上的第一个索引提取出来作为冗余保存在非叶子节点中，非叶子节点大小固定且只保存索引（严格上还有和叶子节点关联的指针），非叶子节点保存更多的索引理论上就代表可以保存更多的数据。</p><p>特点：非叶子节点不存储data，只保存冗余索引，可保存更多索引；叶子节点包含所有索引字段；叶子节点用指针连接，提高区间访问性能。</p><p><img src="/images/mysql/B+Trees.png" alt="B+Trees"></p><p>MySQL的B+树：</p><p><img src="/images/mysql/MySQLB+Trees.png" alt="MySQL B+Trees"></p><p>MySQL对B+树同样做了优化：叶子节点间使用的是双向指针，B+树原本使用的是单向指针</p><p>B＋树相对B-树做了哪些优化？</p><p>a）B＋树的非叶子节点只保存索引，而B-树的非叶子节点保存索引和数据。B+树的叶子节点包含所有的索引元素</p><p>b）B＋树相邻的叶子节点之间有双向的指针，保存相邻节点的磁盘地址，范围查找更友好</p><p>补充：MySQL的数据是保存在磁盘中，存储位置在磁盘中随机，取决于写数据时通过磁道写入的磁盘位置。查询数据时的性能消耗主要发生在磁盘IO，当查找数据时从根节点开始，将磁盘页load到内存中和查询条件比较，把满足条件的下一个磁盘页load到内存中再次比较查找，重复操作最终找到目标数据。</p><p>个人理解：树的高度越低，磁盘页load到内存的次数越少，IO少了所以性能会更高。</p><p>优化：所有的根节点作为常驻内存保存。非叶子节点也可以作为内存进行保存。</p><h4 id="为什么MySQL选择B-树而不是B-树？"><a href="#为什么MySQL选择B-树而不是B-树？" class="headerlink" title="为什么MySQL选择B+树而不是B-树？"></a>为什么MySQL选择B+树而不是B-树？</h4><p>每个节点（磁盘页）大小的选择是有讲究的，默认为16kb大小（16384b），大小可以修改但是不推荐。</p><p>数据表中每一行的数据通常不会超过1kb（按照表中几十个字段估算，没有文本格式大文件的情况），这样每个叶子节点可以保存16条数据</p><p>使用B-树时：非叶子节点同样保存data数据，<code>数据总量 = 16 ^ n </code>，其中n代表树的高度</p><p>使用B+树时：B+树的非叶子节点保存的是索引（按大点算bigint格式占8字节）和指向下一个磁盘页的指针地址（C语言实现约占6字节），这样非叶子节点可以保存的索引个数约为：<code>16384 / (8+6) = 1170</code>，三层高度的树可以保存数据总量约为：<code>1170 * 1170 * 16</code>，两千万+数据</p><p>B+树的高度是由非叶子节点存放的元素个数决定的，存放的越多树的高度越低，查询效率也就越高（load到内存的I/O次数少）。显然相同数据量的情况下，B+树的高度远远小于B-树，性能更高</p><h4 id="InnoDB索引（聚集）和MyISAM索引（非聚集）："><a href="#InnoDB索引（聚集）和MyISAM索引（非聚集）：" class="headerlink" title="InnoDB索引（聚集）和MyISAM索引（非聚集）："></a>InnoDB索引（聚集）和MyISAM索引（非聚集）：</h4><p>InnoDB存储引擎保存的索引和数据在同一个文件中 .ibd</p><p>MyISAM存储引擎保存的索引和数据在不同的文件中 .MYD 和 .MYI</p><p>注意：存储引擎描述的是数据表而不是描述数据据，最终生效的肯定是修饰数据表的存储引擎</p><p>存储引擎和磁盘保存文件格式的关系：</p><p><img src="/images/mysql/datasave.png" alt="datasave"></p><h4 id="为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？"><a href="#为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？" class="headerlink" title="为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？"></a>为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？</h4><p>开发人员在设计InnoDB表的时候，ibd文件必须要用一个B+树的数据文件来组织</p><p>表自带主键索引的情况，直接用主键索引来组织整张表的所有数据</p><p>不创建主键时，从表的第一列开始选择所有数据都不相等的列来组织B+树</p><p>如果选不到，MySQL会创建一个隐藏列来组织整张表的数据</p><p>为了减少MySQL的工作量，索引应该由我们程序员提前创建好</p><h4 id="为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？"><a href="#为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？" class="headerlink" title="为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？"></a>为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？</h4><p>索引定位查找数据时，都是从根节点开始查找数据并比较</p><p>整型数字的比较速度比字符串（逐个字符比较ASCII码）比较速度快</p><p>另外整型和字符串或者uuid相比，更能节省磁盘空间（通常比较贵SSD）</p><p>索引维护到B+树中会排好序，自增每次新增都添加到树的最后，减少树的分裂和平衡</p><h4 id="InnoDb存储引擎的主键索引树和二级索引树的区别？"><a href="#InnoDb存储引擎的主键索引树和二级索引树的区别？" class="headerlink" title="InnoDb存储引擎的主键索引树和二级索引树的区别？"></a>InnoDb存储引擎的主键索引树和二级索引树的区别？</h4><p>主键索引树的叶子节点保存表中所有的数据</p><p>二级索引树的叶子节点保存组织整张表数据的聚集索引的值（通常是主键，也可能是MySQL选择的列或者隐藏列rowid）</p><p>MySQL这样设计可以减少数据的冗余节省存储空间，也保证了数据的一致性减少复杂度</p><p>二级索引查找数据时，是先找到主键索引，再通过主键索引回表到聚簇索引上面找到目标数据</p><p>二级索引其实也是稀疏的，是非聚簇索引</p><p><strong>联合索引：</strong>多个字段共同组织成一个索引</p><p>理想情况是通过1到3个联合索引把业务上80%的查询覆盖到，在加上几个单值索引覆盖剩余的业务</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YeahWorld</title>
      <link href="/posts/blog-get//"/>
      <url>/posts/blog-get//</url>
      
        <content type="html"><![CDATA[<blockquote><p>距上次写Blog 近一年，由于最近换新工作，换了工作电脑所以决定切换主题从心开始</p></blockquote><br><p>0、安装Hexo前置条件：<code>Node.js</code> 和 <code>Git</code> 安装完成</p><p>（node -v，npm -v，git –version查看是否已安装）</p><p><code>Node.js</code> 和 <code>Git</code> 没有安装的同学请自行查找安装方法，资料很多且不复杂</p><br><p>1、安装Hexo客户端命令：<code>npm install -g hexo-cli</code></p><p>问题：执行上述安装Hexo命令，窗口提示 <font color="red">idealTree:npm: sill idealTree buildDeps</font></p> <span id="more"></span> <p>解决：(产生问题的原因是，国外镜像链接失败)</p><pre class=" language-java"><code class="language-java"># 设置为国内的阿里镜像npm config set registry https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org# 检查阿里镜像是否设置成功npm config get registry# 镜像设置成功后展示如下https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span class="token operator">/</span></code></pre><p>切换镜像后，重新执行安装客户端命令，执行成功！</p><br><p>2、Hexo安装完成后执行如下命令，Hexo会在<code>&lt;folder&gt;</code>文件夹下创建所需文件：</p><pre class=" language-java"><code class="language-java">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ cd <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ npm install</code></pre><p>进入到 Hexo 安装路径，执行 <code>hexo s</code>命令，启动成功后按照提示访问<code>http://localhost:4000/</code> </p><br><p>3、Hexo常用命令（这里直接拷贝<code>helloworld</code> 中的快速开始）</p><p><strong>Create a new post</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p><strong>Run server</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><p><strong>Generate static files</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><p><strong>Deploy to remote sites</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info:  <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><br><p>4、Hexo安装完成，首先想到的就是主题。之前使用的是<a href="https://butterfly.js.org/">butterfly</a>主题，尝试过不少美化和特效，现在换成<a href="https://github.com/iissnan/hexo-theme-next/">next</a>主题看起来更加精简，可惜了之前的全局自动播放音乐插件（花了不少时间做好的，心碎~）</p><br><p>5、主题有了，添加背景音乐（情有独钟，因为小时候觉得QQ空间的背景音乐很酷）</p><p>这里笔者使用的是<font color="red">网易云插件的外链</font>来做背景音乐，全局音乐没得问题，可惜进入Blog没有自动播放</p><p>网易云外链获取方式：登录网易云进入目标歌单（或单曲），点击分享 链接使用浏览器打开，生成外链即可</p><p>参考文章：<a href="https://blog.csdn.net/qq_39720594/article/details/105401774">Hexo + Next 主题实现全局播放背景音乐</a></p><p>文中推荐的<font color="red">使用Aplayer + MetingJS插件</font>笔者多次尝试扔没有成功（许是遗漏操作）</p><br><p>6、使用 live2 在页面右下 添加萌娘，简单有趣</p><p>a) 准备工作，执行下面命令</p><pre class=" language-java"><code class="language-java"># 安装 live2 插件npm install <span class="token operator">--</span>save hexo<span class="token operator">-</span>helper<span class="token operator">-</span>live2d# 安装人物模型 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xiazeyu<span class="token operator">/</span>live2d<span class="token operator">-</span>widget<span class="token operator">-</span>modelsnpm install live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu</code></pre><p>b) hexo 安装目录<code>_config.yml</code>配置文件添加如下：</p><pre class=" language-java"><code class="language-java">live2d<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  scriptFrom<span class="token operator">:</span> local  model<span class="token operator">:</span>     use<span class="token operator">:</span> live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu #模型选择  display<span class="token operator">:</span>     position<span class="token operator">:</span> right  #模型位置    width<span class="token operator">:</span> <span class="token number">150</span>       #模型宽度    height<span class="token operator">:</span> <span class="token number">300</span>      #模型高度  mobile<span class="token operator">:</span>     show<span class="token operator">:</span> <span class="token boolean">false</span>      #是否在手机端显示</code></pre><p>c) 重启验证是否生效：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p><br><p>7、参考文章：<a href="https://jlj98.top/hexo-instructions/">Hexo搭建博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 扬帆起航 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
