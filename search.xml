<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis数据结构深入学习</title>
      <link href="/posts/redis-family/2/"/>
      <url>/posts/redis-family/2/</url>
      
        <content type="html"><![CDATA[<p><strong>List常用API</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">/</span><span class="token operator">></span> help <span class="token annotation punctuation">@list</span>LPUSH key element <span class="token punctuation">[</span>element <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>RPOP keyRPUSH key element <span class="token punctuation">[</span>element <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>LPOP keyBLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> timeoutBRPOP key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> timeoutBRPOPLPUSH source destination timeoutRPOPLPUSH  source destinationLINDEX key indexLLEN keyLINSERT key BEFORE<span class="token operator">|</span>AFTER pivot elementLRANGE key start stopLREM key count elementLSET key index elementLTRIM key start stop </code></pre> <span id="more"></span> <p>List是一个有序(按加入的时序排序)的数据结构，Redis采用<font color="red">quicklist（双端链表） 和 ziplist</font> 作为List的底层实现。</p><p>可以通过设置每个ziplist的最大容量，quicklist的数据压缩范围，提升数据存取效率</p><pre><code>list-max-ziplist-size  -2        //  单个ziplist节点最大能存储  8kb  ,超过则进行分裂,将数据存储在新的ziplist节点中list-compress-depth  1        //  0 代表所有节点，都不进行压缩，1， 代表从头节点往后走一个，尾节点往前走一个不用压缩，其他的全部压缩，2，3，4 ... 以此类推</code></pre><p><a href="https://www.processon.com/view/link/6295f9985653bb788c8546fe">Redis - quicklist 数据结构：</a></p><p><a href="https://www.processon.com/view/link/6295f9b27d9c085adb7a7561">Redis - ziplist 数据结构：</a></p><p><strong>Hash常用API</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">/</span><span class="token operator">></span> help  <span class="token annotation punctuation">@hash</span> HSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>HGET key fieldHMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>HKEYS keyHGETALL keyHVALS keyHEXISTS key fieldHDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>HINCRBY key field incrementHINCRBYFLOAT key field incrementHLEN keyHSCAN key cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>HSETNX key field valueHSTRLEN key field </code></pre><p>Hash 数据结构底层实现为一个<font color="red">字典( dict )</font>，也是RedisBb用来存储K-V的数据结构,当数据量比较小，或者单个元素比较小时，底层用<font color="red">ziplist存储</font>，数据大小和元素数量阈值可以通过如下参数设置。</p><pre class=" language-java"><code class="language-java">hash<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>entries  <span class="token number">512</span>    <span class="token comment" spellcheck="true">//  ziplist 元素个数超过 512 ，将改为hashtable编码 </span>hash<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>value    <span class="token number">64</span>      <span class="token comment" spellcheck="true">//  单个元素大小超过 64 byte时，将改为hashtable编码</span></code></pre><p><a href="https://www.processon.com/view/link/6295f973e401fd2eed19c806">Redis - hash 数据结构：</a></p><p><strong>Set常用API</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">/</span><span class="token operator">></span> help  <span class="token annotation punctuation">@set</span>SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>              SCARD key                                                 SISMEMBER key memberSPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SMEMBERS keySRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SMOVE source destination memberSUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>SSCAN key cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> </code></pre><p>Set 为无序的，自动去重的集合数据类型，Set 数据结构底层实现为一个<font color="red">value 为 null 的 字典( dict )</font>，当数据可以用整形表示时，Set集合将被编码为<font color="red">intset</font>数据结构。两个条件任意满足时<br>Set将用hashtable存储数据。1， 元素个数大于 set-max-intset-entries , 2 ， 元素无法用整形表示 </p><pre class=" language-java"><code class="language-java">set<span class="token operator">-</span>max<span class="token operator">-</span>intset<span class="token operator">-</span>entries <span class="token number">512</span>       <span class="token comment" spellcheck="true">// intset 能存储的最大元素个数，超过则用hashtable编码</span></code></pre><p><a href="https://www.processon.com/view/link/6295f95b1e0853255ddd2439">Redis - set 数据结构：</a></p><p><strong>ZSet常用API</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">/</span><span class="token operator">></span> help  <span class="token annotation punctuation">@sorted_set</span>ZADD key <span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> <span class="token punctuation">[</span>INCR<span class="token punctuation">]</span> score member <span class="token punctuation">[</span>score member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>ZCARD keyZCOUNT key min maxZINCRBY key increment memberZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>ZRANK key memberZREM key member <span class="token punctuation">[</span>member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>ZREMRANGEBYRANK key start stopZREMRANGEBYSCORE key min maxZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>ZREVRANGEBYSCORE key max min <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>ZREVRANK key memberZSCAN key cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>ZSCORE key member</code></pre><p>ZSet  为有序的，自动去重的集合数据类型，ZSet 数据结构底层实现为 <font color="red">字典(dict) + 跳表(skiplist) </font>，当数据比较少时，用ziplist编码结构存储。 </p><pre class=" language-java"><code class="language-java">zset<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>entries  <span class="token number">128</span>    <span class="token comment" spellcheck="true">// 元素个数超过128 ，将用skiplist编码</span>zset<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>value     <span class="token number">64</span>     <span class="token comment" spellcheck="true">//  单个元素大小超过 64 byte, 将用 skiplist编码</span></code></pre><p><a href="https://www.processon.com/view/link/6295f943e0b34d481b3cc017">Redis - zset 数据结构：</a></p><p><a href="https://www.processon.com/view/link/6295f8fb1e0853255ddd234c">Redis - skiplist 数据结构：</a></p><p>补充：<a href="https://www.processon.com/view/link/628e1fdd0791291ba20185c4">Redis - string 数据结构：</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础学习和string数据结构初探</title>
      <link href="/posts/redis-family/1/"/>
      <url>/posts/redis-family/1/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis基本特性"><a href="#Redis基本特性" class="headerlink" title="Redis基本特性"></a><code>Redis</code>基本特性</h4><p>a) 非关系型的<font color="red">键值对</font>数据库，可以根据键以O(1) 的时间复杂度取出或插入关联值</p><p>b) <code>Redis</code> 的数据是存在<font color="red">内存</font>中的</p><p>c) 键值对中键的类型可以是字符串，整型，浮点型等，且键是唯一的</p><p>d) 键值对中的值类型可以是string，hash，list，set，sorted set 等</p><p>e) <code>Redis</code> 内置了复制，磁盘持久化，<code>LUA</code>脚本，事务，<font color="orange">SSL,  ACLs，客户端缓存，客户端代理等功能（6.0新特性）</font></p><p>f) 通过<code>Redis</code> 哨兵和<code>Redis Cluster</code> 模式提供高可用性</p> <span id="more"></span> <h4 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a><code>Redis</code>应用场景</h4><p>a) 计数器<br>可以对 String 进行自增自减运算，从而实现计数器功能。<code>Redis</code> 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 </p><p>b) 分布式ID生成<br>利用自增特性，一次请求一个大一点的步长如 <code>incr 2000</code> ,缓存在本地使用，用完再请求。</p><p>c) 海量数据统计<br>位图（bitmap）:存储是否参过某次活动，是否已读谋篇文章，用户是否为会员， 日活统计。</p><p>d) 会话缓存<br>可以使用 <code>Redis</code> 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p>e) 分布式队列/阻塞队列<br>List 是一个双向链表，可以通过 <code>lpush/rpush</code> 和 <code>rpop/lpop</code> 写入和读取消息。可以通过使用<code>brpop/blpop</code> 来实现阻塞队列。</p><p>f) 分布式锁实现<br>在分布式场景下，无法使用基于进程的锁来对多个节点上的进程进行同步。可以使用 <code>Redis</code> 自带的 <code>SETNX</code> 命令实现分布式锁。</p><p>g) 热点数据存储<br>最新评论，最新文章列表，使用list 存储，<code>ltrim</code>取出热点数据，删除老数据。</p><p>h) 社交类需求<br>Set 可以实现交集，从而实现共同好友等功能，Set通过求差集，可以进行好友推荐，文章推荐。</p><p>i) 排行榜<br>sorted_set可以实现有序性操作，从而实现排行榜等功能。</p><p>j) 延迟队列<br>使用sorted_set，使用 【当前时间戳 + 需要延迟的时长】做score, 消息内容作为元素,调用<code>zadd</code>来生产消息，消费者使用<code>zrangbyscore</code>获取当前时间之前的数据做轮询处理。消费完再删除任务 rem  key  member</p><p><code>Redis</code> 的key 都是字符串（<code>SDS</code>， simple dynamic string）类型，命令由客户端发送给服务端都会转换为字节流的形式，虽然看起来可能是数字、浮点数、或者字符串多种类型</p><pre class=" language-java"><code class="language-java"><span class="token operator">></span> set <span class="token number">1</span> a <span class="token comment" spellcheck="true">// 数字key</span><span class="token operator">></span> get <span class="token number">1</span><span class="token operator">></span> set <span class="token number">0.5</span> b <span class="token comment" spellcheck="true">// 浮点key</span><span class="token operator">></span> get <span class="token number">0.5</span><span class="token operator">></span> set a c <span class="token comment" spellcheck="true">// 字符串key</span><span class="token operator">></span> get a以上key 发送到服务端最终都是以字节流的形式</code></pre><p><code>SDS</code> 的特点：</p><p>a）二进制安全的数据结构，安全体现在不会丢数据（<code>c：char data[]="g\0ao"</code>，C 语言以<code>"\0"</code> 作为字符串结尾标记，业务数据存在<code>"\0"</code>时存在安全问题）</p><p>b）内存预分配机制，防止频繁扩容产生的内存分配问题</p><p>c）兼容C语言的函数库</p><p>扩容示例：</p><pre class=" language-java"><code class="language-java">redis<span class="token operator">:</span>  sds<span class="token operator">:</span>    free<span class="token operator">:</span> <span class="token number">0</span>    len<span class="token operator">:</span> <span class="token number">3</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"gao"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"gao123"</span>        len<span class="token operator">:</span> <span class="token number">3</span>    addlen<span class="token operator">:</span> <span class="token function">3</span>    <span class="token punctuation">(</span>len <span class="token operator">+</span> addlen<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">12</span>  <span class="token comment" spellcheck="true">//扩容，(现有长度+需要增加长度)*2</span>    <span class="token comment" spellcheck="true">// 成倍扩容，当长度len=1024，再扩容每次增加1M，(所以使用 setbit 设置大点的空间，防止频繁扩容)</span>      append，setbit     sds<span class="token operator">:</span>      free<span class="token operator">:</span> <span class="token number">6</span>      len<span class="token operator">:</span> <span class="token number">6</span>      <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"gao123"</span>  </code></pre><p>设计思想：</p><pre class=" language-java"><code class="language-java">K<span class="token operator">-</span>V：map <span class="token operator">-</span><span class="token operator">></span> dict，数据库：海量数据的存储<span class="token number">1</span>、数组：<span class="token function">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 随机访问，下表<span class="token number">2</span>、链表：<span class="token function">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 头结点，遍历<span class="token number">3</span>、数：<span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 优化的比较好的场景，二分查找    <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> 任意数据进行随机散列，并且把hash 值转换为一个自然数<span class="token punctuation">[</span>大<span class="token punctuation">]</span>创建一个大的数组：arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> 自然数<span class="token punctuation">[</span>大<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> redis 就是这么干的<span class="token number">1</span>、任意相同的输入，一定能得到相同的输出<span class="token number">2</span>、不同的输入，可能得到相同的输出把现实中无限的数据放到有限的集合中，肯定会产生hash 冲突    <span class="token punctuation">(</span>k1<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>k3<span class="token punctuation">,</span>v3<span class="token punctuation">)</span>    <span class="token function">hash</span><span class="token punctuation">(</span>k1<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token function">hash</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">1</span>    arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>k1<span class="token punctuation">,</span>v1<span class="token punctuation">,</span>next<span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">)</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>k3<span class="token punctuation">,</span>v3<span class="token punctuation">,</span>next<span class="token operator">-</span><span class="token operator">></span>k2<span class="token punctuation">)</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span>v2<span class="token punctuation">,</span>next<span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">)</span>产生hash 冲突时，redis 使用的是头插法redis 是比较基础的语言，没有那么多高级特性，没有那么多工具可以用，是redis 作者自己实现的通过链表法来解决碰撞，java 中的hashMap 要复杂得多key：stringvalue：string，hash，list，set，sorted set</code></pre><p><a href="https://www.processon.com/view/link/628e1fdd0791291ba20185c4">Redis之String 类型数据结构直通车</a></p><p><code>Redis6.0</code> 多线程，但是最终执行用户请求是在单线程中进行的，渐进式扩容很有必要</p><p>有趣命令：</p><pre class=" language-java"><code class="language-java"><span class="token operator">></span> type <span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//查看key的类型</span>string<span class="token operator">></span> object encoding <span class="token number">100</span> <span class="token comment" spellcheck="true">//key 所对应的值，在redis 底层是一个什么样的编码格式</span><span class="token string">"int"</span><span class="token operator">></span> object encoding str<span class="token string">"embstr"</span><span class="token operator">></span> object encoding <span class="token number">0.1</span><span class="token string">"int"</span>    <span class="token keyword">int</span> <span class="token operator">/</span> embstr 都是redis 对内存方面的优化</code></pre><p><code>Redis</code>求模小优化：</p><pre class=" language-java"><code class="language-java">任意数 <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">^</span>n <span class="token comment" spellcheck="true">//对CPU 不友好，累除法</span>任意数 <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//一次位运算</span></code></pre><p><code>Redis</code> 对于值是string 类型的底层编码结构分析：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//type [key]，查看key 的类型</span><span class="token comment" spellcheck="true">//object encoding [key]，查值在底层的编码格式</span><span class="token comment" spellcheck="true">//redis 中所有对象的封装</span>typedef struct redisObject <span class="token punctuation">{</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>  unsigned type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//约束客户端命令，当前类型。位域的语法，占4个bit 位</span>  unsigned encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编码格式，同样占4个bit 位</span>  unsigned lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//24个bit 位，也就是3 个字节</span>  <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//引用计数法，4个字节</span>  <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数据真正存放的位置，8个字节</span><span class="token punctuation">}</span> robj<span class="token punctuation">;</span>redisObject 占<span class="token number">16</span>个字节的空间cache line：<span class="token number">64</span>字节，<span class="token number">64</span> <span class="token operator">-</span> <span class="token number">16</span> <span class="token operator">=</span> <span class="token number">48</span> 字节，肯定可以利用起来<span class="token number">48</span>个字节使用sdshdr8的数据结构存储，因为<span class="token number">48</span>在数据范围 <span class="token number">2</span><span class="token operator">^</span><span class="token number">5</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">~</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">8</span><span class="token operator">-</span><span class="token number">1</span> 之间struct <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr8 <span class="token punctuation">{</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 表示&amp;nbsp;2^5&amp;nbsp;~ 2^8-1 的数据&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span>    uint8_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>    unsigned <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>sds本身消耗<span class="token number">4</span>个字节，其中len、alloc、flags各占一个字节，另外<span class="token string">'\0'</span>占一个字节，因为兼容C语言的函数库最终：<span class="token number">48</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">44</span> 字节，用来存放实际的数据</code></pre><p>对于string 类型的value 有结论如下：</p><pre class=" language-java"><code class="language-java">value 值是string 类型的底层编码结构：<span class="token number">1</span>、value值的长度小于等于<span class="token number">20</span>，尝试转换成数字转换成功，底层使用<span class="token keyword">int</span> 编码格式<span class="token number">2</span>、value值不满足条件<span class="token number">1</span>，且长度小于等于44redis 底层使用embstr 编码结构<span class="token number">3</span>、value值不满足<span class="token number">1</span>和<span class="token number">2</span>条件，使用row 编码结构也就是sds 的数据结构，简单动态字符串</code></pre><p>扩展分析：</p><pre class=" language-java"><code class="language-java">亿级日活的统计：bit 的特点，除了<span class="token number">0</span> 就是<span class="token number">1</span>，所以可以用<span class="token number">1</span>个bit 位表示登陆状态像这样<span class="token number">1</span>个字节就可以表示<span class="token number">8</span>个用户       <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>   <span class="token operator">--</span> 登陆状态offset<span class="token operator">:</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>命令：setbit key offset <span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span>   日期可以作为一个key 使用，“<span class="token number">2022</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">26</span>”变种：userId 是数字时，可以作为偏移量使用setbit a<span class="token operator">-</span>bit<span class="token operator">-</span>map userId <span class="token number">1</span>setbit a<span class="token operator">-</span>bit<span class="token operator">-</span>map userId <span class="token number">1</span>getbit a<span class="token operator">-</span>bit<span class="token operator">-</span>map <span class="token number">8</span>userId<span class="token operator">:</span>bit<span class="token operator">:</span> <span class="token number">0</span><span class="token operator">/</span><span class="token function">1</span> <span class="token punctuation">(</span>默认值是<span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>简单测试：</p><pre class=" language-java"><code class="language-java"><span class="token operator">></span> setbit login_05_26 <span class="token number">100</span> <span class="token number">1</span><span class="token operator">></span> setbit login_05_26 <span class="token number">100</span> <span class="token number">1</span><span class="token operator">></span> setbit login_05_26 <span class="token number">100</span> <span class="token number">1</span><span class="token operator">></span> getbit login_05_26 <span class="token number">100</span>  <span class="token comment" spellcheck="true">//获取日期5月26日用户100的活跃状态，id特别大可以减固定值优化</span><span class="token operator">></span> setbit login_05_26 <span class="token number">100</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">//恢复状态</span><span class="token operator">></span> getbit login_05_26 <span class="token number">100</span><span class="token operator">></span> STRLEN login_05_26 <span class="token comment" spellcheck="true">//长度13 字节。100/8bit = 12.5 所以分配13个字节</span><span class="token operator">></span> type login_05_26 <span class="token comment" spellcheck="true">//string 类型的数据</span><span class="token operator">></span> get login_05_26 <span class="token comment" spellcheck="true">//可以执行命令，获取的数据是内存中的存储，没有实际意义</span><span class="token operator">></span> setbit login_05_26 <span class="token number">100</span> <span class="token number">1</span><span class="token operator">></span> setbit login_05_26 <span class="token number">101</span> <span class="token number">1</span><span class="token operator">></span> setbit login_05_26 <span class="token number">102</span> <span class="token number">1</span><span class="token operator">></span> setbit login_05_26 <span class="token number">103</span> <span class="token number">1</span><span class="token operator">></span> BITCOUNT login_05_26 <span class="token comment" spellcheck="true">//统计bit位是1的个数：4</span><span class="token operator">></span> strlen login_05_26 <span class="token comment" spellcheck="true">//13个字节</span><span class="token operator">></span> BITCOUNT login_05_26 <span class="token number">0</span> <span class="token number">12</span> <span class="token comment" spellcheck="true">//一共13个字节，从索引0开始，所以是0和12。可以统计一部分数据根据索引</span>string 表示数据最大是512M，索引位是<span class="token number">2</span><span class="token operator">^</span><span class="token number">32</span><span class="token operator">-</span><span class="token number">1</span>。最多可表示这么多的用户</code></pre><p>另一个扩展分析：</p><pre class=" language-java"><code class="language-java">login_05_26<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>login_05_27<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>连续登陆情况：按位与再统计<span class="token operator">></span> BITOP and login_05_26<span class="token operator">-</span><span class="token number">27</span> login_05_26 login_05_27 <span class="token comment" spellcheck="true">//按位与操作，结果存到login_05_26-27中</span><span class="token operator">></span> BITCOUNT login_05_26<span class="token operator">-</span><span class="token number">27</span> <span class="token comment" spellcheck="true">//再做一次bitcount可以得到连续登陆的结果</span>login_05_24<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>login_05_25<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>login_05_26<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>login_05_27<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>login_05_28<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>login_05_29<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>login_05_30<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>周活：按位或，有一天登陆就行<span class="token operator">></span> BITOP or login_05_26<span class="token operator">-</span><span class="token number">27</span><span class="token operator">-</span>active login_05_26 login_05_27 <span class="token comment" spellcheck="true">//两天内有一天登陆就行</span><span class="token operator">></span> BITCOUNT login_05_26<span class="token operator">-</span><span class="token number">27</span><span class="token operator">-</span>active    redis 源码有判断只能是<span class="token number">0</span>或<span class="token number">1</span>，按位与 按位或，效率非常高汉明重量 按位操作 有兴趣的同学可以了解</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YeahWorld</title>
      <link href="/posts/blog-get//"/>
      <url>/posts/blog-get//</url>
      
        <content type="html"><![CDATA[<blockquote><p>距上次写Blog 近一年，由于最近换新工作，换了工作电脑所以决定切换主题从心开始</p></blockquote><br><p>0、安装Hexo前置条件：<code>Node.js</code> 和 <code>Git</code> 安装完成</p><p>（node -v，npm -v，git –version查看是否已安装）</p><p><code>Node.js</code> 和 <code>Git</code> 没有安装的同学请自行查找安装方法，资料很多且不复杂</p><br><p>1、安装Hexo客户端命令：<code>npm install -g hexo-cli</code></p><p>问题：执行上述安装Hexo命令，窗口提示 <font color="red">idealTree:npm: sill idealTree buildDeps</font></p> <span id="more"></span> <p>解决：(产生问题的原因是，国外镜像链接失败)</p><pre class=" language-java"><code class="language-java"># 设置为国内的阿里镜像npm config set registry https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org# 检查阿里镜像是否设置成功npm config get registry# 镜像设置成功后展示如下https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span class="token operator">/</span></code></pre><p>切换镜像后，重新执行安装客户端命令，执行成功！</p><br><p>2、Hexo安装完成后执行如下命令，Hexo会在<code>&lt;folder&gt;</code>文件夹下创建所需文件：</p><pre class=" language-java"><code class="language-java">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ cd <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ npm install</code></pre><p>进入到 Hexo 安装路径，执行 <code>hexo s</code>命令，启动成功后按照提示访问<code>http://localhost:4000/</code> </p><br><p>3、Hexo常用命令（这里直接拷贝<code>helloworld</code> 中的快速开始）</p><p><strong>Create a new post</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p><strong>Run server</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><p><strong>Generate static files</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><p><strong>Deploy to remote sites</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info:  <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><br><p>4、Hexo安装完成，首先想到的就是主题。之前使用的是<a href="https://butterfly.js.org/">butterfly</a>主题，尝试过不少美化和特效，现在换成<a href="https://github.com/iissnan/hexo-theme-next/">next</a>主题看起来更加精简，可惜了之前的全局自动播放音乐插件（花了不少时间做好的，心碎~）</p><br><p>5、主题有了，添加背景音乐（情有独钟，因为小时候觉得QQ空间的背景音乐很酷）</p><p>这里笔者使用的是<font color="red">网易云插件的外链</font>来做背景音乐，全局音乐没得问题，可惜进入Blog没有自动播放</p><p>网易云外链获取方式：登录网易云进入目标歌单（或单曲），点击分享 链接使用浏览器打开，生成外链即可</p><p>参考文章：<a href="https://blog.csdn.net/qq_39720594/article/details/105401774">Hexo + Next 主题实现全局播放背景音乐</a></p><p>文中推荐的<font color="red">使用Aplayer + MetingJS插件</font>笔者多次尝试扔没有成功（许是遗漏操作）</p><br><p>6、使用 live2 在页面右下 添加萌娘，简单有趣</p><p>a) 准备工作，执行下面命令</p><pre class=" language-java"><code class="language-java"># 安装 live2 插件npm install <span class="token operator">--</span>save hexo<span class="token operator">-</span>helper<span class="token operator">-</span>live2d# 安装人物模型 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xiazeyu<span class="token operator">/</span>live2d<span class="token operator">-</span>widget<span class="token operator">-</span>modelsnpm install live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu</code></pre><p>b) hexo 安装目录<code>_config.yml</code>配置文件添加如下：</p><pre class=" language-java"><code class="language-java">live2d<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  scriptFrom<span class="token operator">:</span> local  model<span class="token operator">:</span>     use<span class="token operator">:</span> live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu #模型选择  display<span class="token operator">:</span>     position<span class="token operator">:</span> right  #模型位置    width<span class="token operator">:</span> <span class="token number">150</span>       #模型宽度    height<span class="token operator">:</span> <span class="token number">300</span>      #模型高度  mobile<span class="token operator">:</span>     show<span class="token operator">:</span> <span class="token boolean">false</span>      #是否在手机端显示</code></pre><p>c) 重启验证是否生效：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p><br><p>7、参考文章：<a href="https://jlj98.top/hexo-instructions/">Hexo搭建博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 扬帆起航 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
