<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL-MVCC多版本并发控制机制</title>
      <link href="/posts/mysql-family/9/"/>
      <url>/posts/mysql-family/9/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL在可重复读隔离级别下如何保证事务较高的隔离性？"><a href="#MySQL在可重复读隔离级别下如何保证事务较高的隔离性？" class="headerlink" title="MySQL在可重复读隔离级别下如何保证事务较高的隔离性？"></a>MySQL在可重复读隔离级别下如何保证事务较高的隔离性？</h2><p>同样的sql查询语句在一个事务里多次执行查询结果相同，就算其它事务对数据有修改也不会影响当前事务sql语句的查询结果。这个隔离性就是靠MVCC(<strong>Multi-Version Concurrency Control</strong>)机制来保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。</p><p>MySQL在<strong>读已提交和可重复读</strong>隔离级别下都实现了MVCC机制。</p><p><font color="red">MySQL在RC和RR隔离级别下，事务第一次查询数据表生成全部数据的<strong>快照</strong>功能，就是通过MVCC多版本控制实现的</font></p><span id="more"></span><p>补充一个事务和锁状态的案例，分别执行下面步骤：</p><p>1、Session1开启事务后，执行查询 select * from account</p><p>2、Session2开启事务后，执行更新 update account set balance = ‘500’ where id = 1;</p><p>3、Session3开启事务后，执行更新 update account set balance = ‘1000’ where id = 1;</p><p>此时Session2的更新操作对id 为1的数据添加了写锁，Session3更新失败超时。</p><p>Session3执行超时期间（MySQL超时时间默认50s左右），查询锁状态如下：</p><p><img src="/images/mysql/mvcc-1.png" alt="mvcc-1"></p><p><img src="/images/mysql/mvcc-2.png" alt="mvcc-2"></p><p><img src="/images/mysql/mvcc-3.png" alt="mvcc-3"></p><p><strong>undo日志版本链与read view机制详解</strong></p><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p><p><img src="/images/mysql/mvcc-undo.png" alt="mvcc-undo"></p><p>在<strong>可重复读隔离级别</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong><font color="red">该视图在事务结束之前永远都不会变化</font>(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成read-view</strong>)，这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p><p><font color="red">事务开启后，即使第一次查询SQL与业务无关，也会创建一致性视图。max_id 是已提交事务中最大的tx_id，max_id可能大于活跃事务数组的tx_id 最大值，也可能在活跃事务数组范围内；min_id 是活跃事务数组中tx_id 的最小值</font></p><p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p><p><strong>关于readview和可见性算法的原理解释</strong></p><p>readview和可见性算法其实就是记录了sql查询那个时刻数据库里提交和未提交所有事务的状态。</p><p>要实现RR隔离级别，事务里每次执行查询操作readview都是使用第一次查询时生成的readview，也就是都是以第一次查询时当时数据库里所有事务提交状态来比对数据是否可见，可以实现每次查询可重复读的效果。</p><p>要实现RC隔离级别，事务里每次执行查询操作readview都会按照数据库当前状态重新生成readview，也就是每次查询都是跟数据库里当前所有事务提交状态来比对数据是否可见，实现的就是每次都能查到已提交最新数据的效果。</p><p><strong>注意：</strong>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的<strong>第一个修改操作或加排它锁</strong>操作(比如select…for update)的语句，事务才真正启动，才会向MySQL申请真正的事务id，MySQL内部是严格按照事务的启动顺序来分配事务id的。</p><p><strong>总结：</strong></p><p>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。</p><p><font color="red">数据是同一套，版本链不同。。MVCC多版本（多版本指的是日志链版本）并发控制不阻塞，读写并行执行。</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-锁机制</title>
      <link href="/posts/mysql-family/8/"/>
      <url>/posts/mysql-family/8/</url>
      
        <content type="html"><![CDATA[<h2 id="锁机制详解"><a href="#锁机制详解" class="headerlink" title="锁机制详解"></a>锁机制详解</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何<strong>保证数据并发访问的一致性、有效性</strong>是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><span id="more"></span><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>性能分类：<strong>悲观锁、乐观锁</strong></p><p>数据操作粒度分类：<strong>表锁、页锁、行锁</strong></p><p>数据库操作类型分类：<strong>读锁和写锁</strong>（都属于悲观锁，有锁等待）、还有<strong>意向锁</strong></p><p><font color="red">乐观锁更适合读多的场景：读多的场景加悲观锁会影响性能，因为读读不互斥加锁没有必要；</font></p><p><font color="red">悲观锁更适合写多的场景：写多的场景乐观锁加锁失败的概率大大增加，不断重试空转CPU影响性能</font></p><p><strong>读锁</strong>（共享锁，S锁(<strong>S</strong>hared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响，比如：</p><blockquote><p> select * from T where id=1 lock in share mode              </p></blockquote><p><strong>写锁</strong>（排它锁，X锁(e<strong>X</strong>clusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁，数据修改操作都会加写锁，查询也可以通过for update加写锁，比如：</p><blockquote><p>select * from T where id=1 for update              </p></blockquote><p><font color="red">读读不互斥，其他都互斥。Serializable 串行化的隔离级别，对所有读写操作都加锁，另外查询不存在的数据或者范围查询会额外对间隙范围的每一行加锁，从而解决幻读的问题</font></p><p><strong>意向锁</strong>（Intention Lock）：又称<strong>I锁</strong>，针对<strong>表锁</strong>，主要是为了<strong>提高加表锁的效率</strong>，是mysql数据库自己加的。当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，逐行判断加表锁的方式效率很低。而这个标识就是意向锁。</p><p>意向锁主要分为：</p><p>意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。</p><p>意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。</p><p><font color="red">意向锁就是给表打的标记，标记当前表中是否有行锁。事务在尝试获取表锁时直接根据标记判断即可，表中已经加过行锁的情况不允许其他事务对当前表加表锁</font></p><p><strong>表锁</strong></p><p>每次操作锁住整张表。<strong>开销小，加锁快</strong>；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。</p><p><font color="red">开销小，加锁快，指的是加锁的这个操作，找到表即可 无需遍历找到某一行的记录。并发性能差，更适合半夜业务量小的时候，进行数据迁移，加锁防止表数据修改迁移完成后解锁</font></p><p>预置表数据：</p><pre><code>-- 建表SQLCREATE TABLE `mylock` (    `id` INT (11) NOT NULL AUTO_INCREMENT,    `NAME` VARCHAR (20) DEFAULT NULL,    PRIMARY KEY (`id`)) ENGINE = MyISAM DEFAULT CHARSET = utf8;-- 插入数据INSERT INTO `mylock` (`id`, `NAME`) VALUES ('1', 'a');INSERT INTO `mylock` (`id`, `NAME`) VALUES ('2', 'b');INSERT INTO `mylock` (`id`, `NAME`) VALUES ('3', 'c');INSERT INTO `mylock` (`id`, `NAME`) VALUES ('4', 'd');</code></pre><p>表锁操作：</p><pre><code>-- 手动增加表锁lock table 表名称 read(write),表名称2 read(write);-- 查看表上加过的锁show open tables;-- 删除表锁unlock tables;</code></pre><p><font color="red">表锁write 添加后，其他事务对当前表的读写操作都会阻塞；表锁read 添加后，其他事务对当前表的更新操作阻塞，读操作不阻塞</font></p><p><strong>页锁</strong></p><p>只有<strong>BDB存储引擎支持页锁</strong>，页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p><p><font color="red">考虑到行锁粒度比较大的问题，页锁粒度更小每次锁住MySQL的一个磁盘页，类似分段锁的思想</font></p><p><strong>行锁</strong></p><p>每次操作锁住一行数据。<strong>开销大，加锁慢</strong>；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><p>InnoDB相对于MYISAM的最大不同有两点：</p><ul><li><strong>InnoDB支持事务（TRANSACTION）</strong></li><li><strong>InnoDB支持行级锁</strong></li></ul><p>注意，InnoDB的行锁实际上是针对索引加的锁(在索引对应的索引项上做标记)，不是针对整个行记录加的锁。并且该索引不能失效，否则会从行锁升级为表锁。(<strong>RR级别会升级为表锁，RC级别不会升级为表锁</strong>)</p><p>比如我们在RR级别执行如下sql</p><blockquote><p>select * from account where name = ‘gao’ for update;    – where条件里的name字段无索引              </p></blockquote><p>则其它Session对该表任意一行记录做修改操作都会被阻塞住。</p><p><font color="red">RR级别下要尽量避免这种情况发生，表锁的并发度最低 极大的影响性能</font></p><p><strong>PS：关于RR级别行锁升级为表锁的原因分析</strong></p><p>因为在RR隔离级别下，需要解决不可重复读和幻读问题，所以在遍历扫描聚集索引记录时，为了防止扫描过的索引被其它事务修改(不可重复读问题) 或 间隙被其它事务插入记录(幻读问题)，从而导致数据不一致，所以MySQL的解决方案就是把所有扫描过的索引记录和间隙都锁上，这里要注意，并不是直接将整张表加表锁，因为不一定能加上表锁，可能会有其它事务锁住了表里的其它行记录。</p><p><strong>间隙锁(Gap Lock)</strong></p><p>间隙锁，锁的就是两个值之间的空隙，<strong>间隙锁是在可重复读隔离级别下才会生效。</strong></p><p>只要在间隙范围内锁了一条不存在的记录会锁住整个间隙范围，不锁边界记录，这样就能防止其它Session在这个间隙范围内插入数据，就解决了可重复读隔离级别的幻读问题。</p><p><font color="red">间隙锁可以彻底解决RR级别的幻读问题，执行 select * from [表名] where id = [不存在id] for update，锁住间隙范围。这里的锁的间隙也是通过索引，对索引范围加锁</font></p><p><strong>临键锁(Next-key Locks)</strong></p><p>Next-Key Locks是行锁与间隙锁的组合。</p><p><font color="red">select * from [表名] where id &gt; 15 for update，查询条件是范围，且范围内存在索引列和间隙列时产生临键锁</font></p><p><strong>总结：</strong></p><p>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。</p><p>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。</p><p>另外，读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。</p><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p><h3 id="锁等待分析"><a href="#锁等待分析" class="headerlink" title="锁等待分析"></a>锁等待分析</h3><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><pre><code>show status like 'innodb_row_lock%';对各个状态量的说明如下：Innodb_row_lock_current_waits: 当前正在等待锁定的数量Innodb_row_lock_time: 从系统启动到现在锁定总时间长度Innodb_row_lock_time_avg: 每次等待所花平均时间Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间Innodb_row_lock_waits: 系统启动后到现在总共等待的次数</code></pre><p>其中比较重要的主要是： <code>Innodb_row_lock_time_avg</code> （等待平均时长）、<code>Innodb_row_lock_waits</code> （等待总次数）、<code>Innodb_row_lock_time</code>（等待总时长）</p><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><p><strong>查看INFORMATION_SCHEMA系统库锁相关数据表</strong></p><pre><code>-- 查看事务select * from INFORMATION_SCHEMA.INNODB_TRX;-- 查看锁，8.0之后需要换成这张表performance_schema.data_locksselect * from INFORMATION_SCHEMA.INNODB_LOCKS;  -- 查看锁等待，8.0之后需要换成这张表performance_schema.data_lock_waitsselect * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;  -- 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到kill trx_mysql_thread_id-- 查看锁等待详细信息show engine innodb status; </code></pre><p><strong>死锁问题分析</strong></p><pre><code>set tx_isolation='repeatable-read';Session_1执行：select * from account where id=1 for update;Session_2执行：select * from account where id=2 for update;Session_1执行：select * from account where id=2 for update;Session_2执行：select * from account where id=1 for update;查看近期死锁日志信息：show engine innodb status; </code></pre><p>大多数情况mysql可以<strong>自动检测死锁</strong>并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁，这种情况我们可以通过日志分析找到对应事务线程id，可以通过kill杀掉。</p><h3 id="锁优化实践"><a href="#锁优化实践" class="headerlink" title="锁优化实践"></a>锁优化实践</h3><ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的SQL尽量放在事务最后执行</li><li>尽可能用低的事务隔离级别</li></ul><p><font color="red">只有在RR级别下才有行锁升级为表锁的情况，因为RR级别要解决各种问题：不可重复读、幻读等，RC级别就不需要解决这些问题</font></p><p>业务中常遇见的下单业务，需要插入订单表insert 和更新库存表update，如何选择顺序？</p><p><strong>先insert 后update 更优</strong>，因为insert 插入的是新增数据，其他事务不会对不存在的数据操作。如果是先update 那么有可能其他事务要操作这条数据而进入等待。<strong>涉及事务加锁SQL放在最后</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-事务</title>
      <link href="/posts/mysql-family/7/"/>
      <url>/posts/mysql-family/7/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库并发执行多个事务对相同的一批数据进行增删改查操作，可能就会导致脏写、脏读、不可重复读、幻读这些问题。这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了<strong>事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制</strong>，用一整套机制来<strong>解决多事务并发问题</strong>。</p><span id="more"></span><h2 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h2><p>事务：一组操作要么全部成功，要么全部失败，目的是保证数据的最终一致性。</p><p>事务具有以下4个属性,通常简称为事务的ACID属性。</p><ul><li>原子性(Atomicity) ：事务操作要么同时成功，要么同时失败。原子性由undo log日志来实现。</li><li>一致性(Consistent) ：使用事务的最终目的，由其它3个特性以及业务代码正确逻辑来实现。</li><li>隔离性(Isolation) ：事务并发执行时，他们内部的操作不能互相干扰。隔离性由MySQL的各种锁以及MVCC机制来实现。</li><li>持久性(Durable) ：一旦提交了事务，它对数据库的改变就应该是永久性的。持久性由redo log日志来实现。</li></ul><h2 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h2><p><font color="red">更新丢失(Lost Update)或脏写</font></p><p>两个或多个事务对同一行数据修改时可能发生，即最后的更新覆盖了由其他事务所做的更新。</p><p><font color="red">脏读（Dirty Reads）</font></p><p>事务A读取到了事务B已经修改但尚未提交的数据</p><p><font color="red">不可重读（Non-Repeatable Reads） </font></p><p>事务A内部的相同查询语句在不同时刻读出的结果不一致</p><p><font color="red">幻读（Phantom Reads）</font></p><p>事务A读取到了事务B提交的新增数据</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>“脏读”、“不可重复读”和“幻读”都是数据库读一致性问题，必须由数据库的事务隔离机制来解决。</p><table><thead><tr><th>隔离级别</th><th>脏读(Dirty Read)</th><th>不可重复读(NonRepeatable Read)</th><th>幻读(Phantom Read)</th></tr></thead><tbody><tr><td>读未提交(Read uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交(Read committed)  <font color="red">RC</font></td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatableread)   <font color="red">RR</font></td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化(Serializable)</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>数据库的隔离级别越严格（上表越靠下越严格），并发性能约好，但相应的成本代价越高。</p><p>查看当前数据库的事务隔离级别：<code>show variables like 'tx_isolation';</code></p><p>设置事务隔离级别：<code>set tx_isolation='REPEATABLE-READ';</code></p><p><strong>Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</strong></p><p>为什么用RR级别的隔离级别？</p><p>我的理解是：隔离性能还不错，同时并发性能比串行化好很多。对代码的业务开发更友好（避免了脏读和不可重读的问题，同时通过间隙锁一定程度上避免幻读的发生）</p><h3 id="事务隔离级别案例分析"><a href="#事务隔离级别案例分析" class="headerlink" title="事务隔离级别案例分析"></a>事务隔离级别案例分析</h3><p>预置表数据：</p><pre><code>CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `balance` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `account` (`name`, `balance`) VALUES ('guan', '450');INSERT INTO `account` (`name`, `balance`) VALUES ('liu', '16000');INSERT INTO `account` (`name`, `balance`) VALUES ('zhang', '2400');</code></pre><p><strong>读未提交：</strong></p><p>1、打开一个客户端A设置隔离级别为读未提交；开启事务并查询表数据</p><p><img src="/images/mysql/tra-1.png" alt="tra-1"></p><p>2、打开一个新的客户端B开启事务，修改表中id为1的数据，不提交事务</p><p><img src="/images/mysql/tra-2.png" alt="tra-2"></p><p>3、到客户端A中重新查询表数据，发现读取到 id 为1的数据是客户端B修改后的数据</p><p><img src="/images/mysql/tra-3.png" alt="tra-3"></p><p>4、客户端B发生回滚，所有操作都会被撤销，此时客户端A查询到的数据就是<strong>脏数据</strong></p><p><font color="red">第3步读取到其他事务修改未提交的数据，带入到程序中处理的情况下，一旦其他事务发生回滚，那么程序中处理的数据就是脏数据。解决这个问题可以用读已提交的隔离级别。</font></p><p><strong>读已提交：</strong></p><p>1、打开一个客户端A，并设置当前事务模式为read committed，查询表account的所有记录</p><p><img src="/images/mysql/tra-4.png" alt="tra-4"></p><p>2、在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p><img src="/images/mysql/tra-5.png" alt="tra-5"></p><p>3、这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，<font color="red">解决了脏读问题</font></p><p><img src="/images/mysql/tra-6.png" alt="tra-6"></p><p>4、客户端B的事务提交，执行commit;</p><p>5、客户端A执行与上一步相同的查询，结果与上一步不一致，即产生了不可重复读的问题</p><p><img src="/images/mysql/tra-7.png" alt="tra-7"></p><p><strong>可重复读</strong></p><p><font color="red">可重复读隔离级别在事务开启的时候，第一次查询是查的数据库里已提交的最新数据，这时候全数据库会有一个快照(并不是真正生成一个快照，有类似功能的实现机制，可以简单这样理解)，在这个事务之后执行的查询操作都是查快照里的数据，别的事务不管怎么修改数据对当前这个事务的查询都没有影响，但是当前事务如果修改了某条数据，那当前事务之后查这条修改的数据就是被修改之后的值，但是查其它数据依然是从快照里查，不受影响。</font></p><p>1、打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</p><p><img src="/images/mysql/tra-8.png" alt="tra-8"></p><p>2、在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p><p><img src="/images/mysql/tra-9.png" alt="tra-9"></p><p>3、在客户端A查询表account的所有记录，与步骤1查询结果一致，没有出现不可重复读的问题</p><p><img src="/images/mysql/tra-10.png" alt="tra-10"></p><p>4、在客户端A，接着执行update account set balance = balance - 50 where id = 1，balance没有变成450-50=400，guan的balance值用的是步骤2中的400来算的，所以是350，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC(multi-version concurrency control)机制，select操作是<strong>快照读（历史版本）</strong>；insert、update和delete是<strong>当前读（当前版本）</strong>。</p><p><img src="/images/mysql/tra-11.png" alt="tra-11"></p><p><font color="red">注意：这里的更新是按照数据表的实际数据更新，尽管查询到的是快照数据</font></p><p>5、重新打开客户端B，插入一条新数据后提交</p><p><img src="/images/mysql/tra-12.png" alt="tra-12"></p><p>6、在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p><p><img src="/images/mysql/tra-13.png" alt="tra-13"></p><p><font color="red">注意：这里没有查到客户端B新增的id等于4的数据，但是可以更新id为4的数据参考步骤7</font></p><p>7、在客户端A执行update account set balance=888 where id = 4；能更新成功，再次查询能查到客户端B新增的数据</p><p><img src="/images/mysql/tra-14.png" alt="tra-14"></p><p><font color="red">显然根据上面的例子可重复读没有完全解决幻读的问题，可重复读加间隙锁可以彻底解决幻读问题</font></p><p><strong>串行化</strong></p><p>1、打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值</p><p><img src="/images/mysql/tra-15.png" alt="tra-15"></p><p>2、打开一个客户端B，并设置当前事务模式为serializable，更新相同的id为1的记录会被阻塞等待，更新id为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁，如果查询的记录不存在会给这条不存在的记录加上锁(这种是间隙锁)。</p><p>如果客户端A执行的是一个范围查询，那么该<strong>范围内的所有行包括每行记录所在的间隙区间范围都会被加锁</strong>。此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。</p><p><font color="red">这种隔离级别并发性极低，开发中很少会用。</font></p><p><img src="/images/mysql/tra-16.png" alt="tra-16"></p><p><img src="/images/mysql/tra-17.png" alt="tra-17"></p><p><font color="red">小结：串行化隔离级别开启后，读取时自动加上共享锁 lock in share mode，写数据时自动加上排他锁 for update，通过读写互斥保证串行化。</font></p><blockquote><p>补充：隔离级别与锁的关系？</p><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p></blockquote><h2 id="事务问题定位"><a href="#事务问题定位" class="headerlink" title="事务问题定位"></a>事务问题定位</h2><pre><code>#查询执行时间超过1秒的事务SELECT    * FROM    information_schema.innodb_trx WHERE    TIME_TO_SEC( timediff( now( ), trx_started ) ) &gt; 1;  #强制结束事务 kill 事务对应的线程id(就是上面语句查出结果里的trx_mysql_thread_id字段的值)</code></pre><h2 id="大事务的影响"><a href="#大事务的影响" class="headerlink" title="大事务的影响"></a>大事务的影响</h2><ul><li>并发情况下，数据库连接池容易被撑爆</li><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>执行时间长，容易造成主从延迟</li><li>回滚所需要的时间比较长</li><li>undo log膨胀</li><li>容易导致死锁</li></ul><p><font color="red">连接池被撑爆可能导致服务崩溃，在微服务中可能导致服务调用失败等一系列问题</font></p><h2 id="事务优化"><a href="#事务优化" class="headerlink" title="事务优化"></a>事务优化</h2><ul><li>将查询等数据准备操作放到事务外</li><li>事务中避免远程调用，远程调用要设置超时，防止事务等待时间太久</li><li>事务中避免一次性处理太多数据，可以拆分成多个事务分次处理</li><li>更新等涉及加锁的操作尽可能放在事务靠后的位置</li><li>能异步处理的尽量异步处理</li><li>应用侧(业务代码)保证数据一致性，非事务执行</li></ul><p><font color="red">简单总结就是大事务拆分成小事务，减少事务发生的时间（加等待超时、异步处理等）</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-优化三</title>
      <link href="/posts/mysql-family/6/"/>
      <url>/posts/mysql-family/6/</url>
      
        <content type="html"><![CDATA[<h2 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a><font color="red">分页查询优化</font></h2><p>预置表：</p><pre><code>CREATE TABLE `employees` (    `id` INT ( 11 ) NOT NULL AUTO_INCREMENT,    `name` VARCHAR ( 24 ) NOT NULL DEFAULT '' COMMENT '姓名',    `age` INT ( 11 ) NOT NULL DEFAULT '0' COMMENT '年龄',    `position` VARCHAR ( 20 ) NOT NULL DEFAULT '' COMMENT '职位',    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间',    PRIMARY KEY ( `id` ),    KEY `idx_name_age_position` ( `name`, `age`, `position` ) USING BTREE ) ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT = '员工记录表';drop procedure if exists insert_emp; delimiter ;;create procedure insert_emp()        begin  declare i int;                      set i=1;                            while(i&lt;=100000)do                     insert into employees(name,age,position) values(CONCAT('gax',i),i,'dev');      set i=i+1;                         end while;end;;delimiter ;call insert_emp();</code></pre><p>分析业务上可能遇到的分页SQL：</p><pre><code>select * from employees limit 10000,10;</code></pre><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p><span id="more"></span><h3 id="常见的分页场景优化："><a href="#常见的分页场景优化：" class="headerlink" title="常见的分页场景优化："></a>常见的分页场景优化：</h3><h4 id="根据自增且连续的主键排序的分页查询"><a href="#根据自增且连续的主键排序的分页查询" class="headerlink" title="根据自增且连续的主键排序的分页查询"></a>根据自增且连续的主键排序的分页查询</h4><p><img src="/images/mysql/opt3-1.png" alt="opt3-1"></p><p><img src="/images/mysql/opt3-2.png" alt="opt3-2"></p><p>上图的第一个SQL表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过<strong>主键排序</strong>。我们再看表 employees ，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，查询结果一致。</p><p>对比执行计划：改写后的 SQL 走了<strong>索引</strong>，而且<strong>扫描的行数大大减少</strong>，执行效率更高。</p><p>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致。</p><p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><h4 id="根据非主键字段排序的分页查询"><a href="#根据非主键字段排序的分页查询" class="headerlink" title="根据非主键字段排序的分页查询"></a>根据非主键字段排序的分页查询</h4><p><img src="/images/mysql/opt3-3.png" alt="opt3-3"></p><p><img src="/images/mysql/opt3-4.png" alt="opt3-4"></p><p>从上面第一个SQL的执行计划可以看出，没有使用索引，并且使用了文件排序。（<strong>扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>）</p><p>其优化的关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，于是可以改写成上面的第二个SQL进行优化</p><p>需要的结果与原 SQL 一致，执行时间减少了一半以上，原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p><h2 id="Join关联查询优化"><a href="#Join关联查询优化" class="headerlink" title="Join关联查询优化"></a><font color="red">Join关联查询优化</font></h2><p>预置表数据：（t1和t2两张表，表结构完全一样，1表10000条数据，2表100条数据）</p><pre><code>CREATE TABLE `t1` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `a` int(11) DEFAULT NULL,  `b` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `idx_a` (`a`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;create table t2 like t1;-- 插入一些示例数据-- 往t1表插入1万行记录drop procedure if exists insert_t1;delimiter ;;create procedure insert_t1()        begin  declare i int;                      set i=1;                            while(i&lt;=10000)do                     insert into t1(a,b) values(i,i);      set i=i+1;                         end while;end;;delimiter ;call insert_t1();-- 往t2表插入100行记录drop procedure if exists insert_t2; delimiter ;;create procedure insert_t2()        begin  declare i int;                      set i=1;                            while(i&lt;=100)do                     insert into t2(a,b) values(i,i);      set i=i+1;                         end while;end;;delimiter ;call insert_t2();</code></pre><h3 id="MySQL的表关联常见有两种算法"><a href="#MySQL的表关联常见有两种算法" class="headerlink" title="MySQL的表关联常见有两种算法"></a>MySQL的表关联常见有两种算法</h3><ul><li><p>Nested-Loop Join 算法</p></li><li><p>Block Nested-Loop Join 算法</p></li></ul><h4 id="嵌套循环连接-Nested-Loop-Join-NLJ-算法"><a href="#嵌套循环连接-Nested-Loop-Join-NLJ-算法" class="headerlink" title="嵌套循环连接 Nested-Loop Join(NLJ) 算法"></a>嵌套循环连接 Nested-Loop Join(NLJ) 算法</h4><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动表</strong>）里取出满足条件的行，然后取出两张表的结果合集。</p><p><img src="/images/mysql/opt3-5.png" alt="opt3-5"></p><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优化器一般会优先选择<strong>小表做驱动表，</strong>用where条件过滤完驱动表，然后再跟被驱动表做关联查询。<strong>使用 inner join 时，排在前面的表并不一定就是驱动表。</strong> <font color="red">注意：这里的小表并不是单纯指数据量小的表，而是指关联字段少的表，比如1表数据10000条范围查找后得到10条 此时1表是小表</font></li><li>当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表是驱动表，左表是被驱动表，当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。</li><li>使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 <strong>Using join buffer</strong> 则表示使用的 join 算法是 NLJ。</li></ul><p><font color="red">简单理解：从一张表（小表）里拿出所有记录，到另一张表（大表）里面去查询。</font></p><p><strong>上面sql的大致流程如下：</strong></p><ol><li>从表 t2 中读取一行数据（如果t2表有查询过滤条件的，用先用条件过滤完，再从过滤结果里取出一行数据）；</li><li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</li><li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</li><li>重复上面 3 步。</li></ol><p>整个过程会读取 t2 表的所有数据(<strong>扫描100行</strong>)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100行</strong>)。因此整个过程扫描了 <strong>200 行</strong>。</p><p><font color="red">注意：这里的扫描指的是扫描磁盘中的完整数据，扫描索引树很快相比扫描磁盘数据可以忽略，</font></p><p>如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join算法。</p><h4 id="基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法"></a>基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法</h4><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。</p><p><img src="/images/mysql/opt3-6.png" alt="opt3-6"></p><p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。</p><p><strong>上面sql的大致流程如下：</strong></p><ol><li>把 t2 的所有数据放入到 <strong>join_buffer</strong> 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。</p><p>这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢？·</p><p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p><p>比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空  join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p><p><font color="red">简单理解：从一张表（小表）里拿出所有记录放入 join_buffer 中，另一张表（大表）每次取出一行到 join_buffer 中去比较。</font></p><p><strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢？</strong></p><p>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是<strong>磁盘扫描</strong>。</p><p>很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。</p><p><font color="red">总结：MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下 NLJ 算法比 BNL算法性能更高。</font></p><h3 id="对于关联sql的优化"><a href="#对于关联sql的优化" class="headerlink" title="对于关联sql的优化"></a>对于关联sql的优化</h3><ul><li><strong>关联字段加索引</strong>，让mysql做join操作时尽量选择NLJ算法，驱动表因为需要全部查询出来，所以过滤的条件也尽量要走索引，避免全表扫描，总之，能走索引的过滤条件尽量都走索引</li><li><strong>小表驱动大表</strong>，写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间</li></ul><p><strong>straight_join解释：straight_join</strong>功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。</p><p>比如：select * from t2 straight_join t1 on t2.a = t1.a; 代表指定mysql选着 t2 表作为驱动表。</p><ul><li><strong>straight_join</strong>只适用于inner join，并不适用于left join，right join。（因为left join，right join已经代表指定了表的执行顺序）</li><li>尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</li></ul><h4 id="对于小表定义的明确"><a href="#对于小表定义的明确" class="headerlink" title="对于小表定义的明确"></a>对于小表定义的明确</h4><p>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，<strong>过滤完成之后</strong>，计算参与 join 的各个字段的总数据量，<strong>数据量小的那个表，就是“小表”</strong>，应该作为驱动表。</p><h4 id="in和exsits优化"><a href="#in和exsits优化" class="headerlink" title="in和exsits优化"></a>in和exsits优化</h4><p>原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集</p><p><strong>in：</strong>当B表的数据集小于A表的数据集时，in优于exists </p><pre><code>select * from A where id in (select id from B)  #等价于：　　for(select id from B){      select * from A where A.id = B.id    }</code></pre><p><strong>exists：</strong>当A表的数据集小于B表的数据集时，exists优于in</p><p>将主查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定主查询的数据是否保留</p><pre><code>select * from A where exists (select 1 from B where B.id = A.id)#等价于:    for(select * from A){      select * from B where B.id = A.id    }    #A表与B表的ID字段应建立索引</code></pre><p>1、EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换，官方说法是实际执行时会忽略SELECT清单，因此没有区别</p><p>2、EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比</p><p>3、EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</p><h2 id="count-查询优化"><a href="#count-查询优化" class="headerlink" title="count(*)查询优化"></a><font color="red">count(*)查询优化</font></h2><p><img src="/images/mysql/opt3-7.png" alt="opt3-7"></p><p><font color="red">注意：以上4条sql只有根据某个字段count不会统计字段为null值的数据行</font></p><p><strong>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</strong></p><p><strong>字段有索引：</strong><code>count(*)≈count(1)&gt;count(字段)&gt;count(主键 id) </code></p><p><font color="red">注意：字段有索引count(字段)统计走二级索引，二级索引存储数据比主键索引少</font></p><p><strong>字段无索引：</strong><code>count(*)≈count(1)&gt;count(主键 id)&gt;count(字段) </code></p><p><font color="red">注意：字段没有索引count(字段)统计走不了索引，count(主键 id)还可以走主键索引</font></p><p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出字段，所以理论上count(1)比count(字段)会快一点。</p><p><font color="red"><code>count(*)</code> 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，</font>所以不需要用count(列名)或count(常量)来替代 <code>count(*)</code>。</p><h3 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h3><p><strong>1、查询mysql自己维护的总行数</strong></p><p>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算</p><p><img src="/images/mysql/opt3-8.png" alt="opt3-8"></p><p>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数(因为有MVCC机制)，查询count需要实时计算</p><p><strong>2、show table status</strong></p><p>如果只需要知道表总行数的<strong>估计值</strong>可以用如下sql查询，性能很高</p><p><img src="/images/mysql/opt3-9.png" alt="opt3-9"></p><p><font color="red">注意：很显然统计的记录数和实际上有偏差，精确统计时不适用</font></p><p><strong>3、将总数维护到Redis里</strong></p><p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难保证表操作和redis操作的事务一致性</p><p><strong>4、增加数据库计数表</strong></p><p>插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p><p><font color="red">注意：在业务系统中对于count查询比较多的场景，增加数据库计数表是很有必要的，至少也要维护在缓存</font></p><h2 id="MySQL数据类型选择"><a href="#MySQL数据类型选择" class="headerlink" title="MySQL数据类型选择"></a><font color="red">MySQL数据类型选择</font></h2><p>在MySQL中，选择正确的数据类型，对于性能至关重要。一般应该遵循下面两步：</p><p>（1）确定合适的大类型：数字、字符串、时间、二进制；</p><p>（2）确定具体的类型：有无符号、取值范围、变长定长等。</p><p>在MySQL数据类型设置方面，尽量用更小的数据类型，因为它们通常有更好的性能，花费更少的硬件资源。并且尽量把字段定义为NOT NULL，避免使用NULL。</p><p><strong>1、数值类型</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>(-128, 127)</td><td>(0, 255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>(-32 768, 32 767)</td><td>(0, 65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>(-8 388 608, 8 388 607)</td><td>(0, 16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 字节</td><td>(-2 147 483 648, 2 147 483 647)</td><td>(0, 4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)</td><td>(0, 18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0, (1.175 494 351 E-38, 3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td><td>0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><p><strong>优化建议</strong></p><ol><li>如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。</li><li>建议使用TINYINT代替ENUM、BITENUM、SET。</li><li>避免使用整数的显示宽度，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT。</li><li>DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置。</li><li>建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作。</li><li>整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。</li></ol><p><font color="red">之前做过的业务上就经常用 long 类型来保存金额（单位：分）,计算简单且易读。另外设置整数字段时，推荐不指定长度，因为没多大实际意义</font></p><p><strong>2、日期和时间</strong></p><table><thead><tr><th>类型</th><th>大小(字节)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 到 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’ 到 ‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 到 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00 到 2038-01-19 03:14:07</td><td>YYYYMMDDhhmmss</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p><strong>优化建议</strong></p><ol><li>MySQL能存储的最小时间粒度为秒。</li><li>建议用DATE数据类型来保存日期。MySQL中默认的日期格式是yyyy-mm-dd。</li><li>用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。</li><li>当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。</li><li>TIMESTAMP是UTC时间戳，与时区相关。</li><li>DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。</li><li>除非有特殊需求，一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题。</li><li>有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。</li></ol><p><font color="red">工作中常用的就是&nbsp;DATETIME 和&nbsp;TIMESTAMP，之前公司用的大都是&nbsp;TIMESTAMP，个人更偏爱&nbsp;DATETIME </font></p><p><strong>3、字符串</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255字节</td><td>定长字符串，char(n)当插入的字符数不足n时(n代表字符数)，插入空格进行补充保存。在进行检索时，尾部的空格会被去掉。</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串，varchar(n)中的n代表最大字符数，插入的字符数不足n时不会补充空格</td></tr><tr><td>TINYBLOB</td><td>0-255字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295字节</td><td>极大文本数据</td></tr></tbody></table><p><strong>优化建议</strong></p><ol><li>字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。</li><li>CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。</li><li>尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联。</li><li>BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。</li><li>BLOB和TEXT都不能有默认值。</li></ol><p><font color="red">做大数据相关的项目时，用到过 text 字段，字段内容自定义可能很长。常用的就是<strong>varchar 和 char</strong>，身份证、手机号这种长度固定的用 char，长度不确定的用 varchar 就行。注意姓名可能不止3个汉字，工作中遇到过客户的名字十几个字的</font></p><blockquote><p>补充一个JAVA常见的问题：String、StringBuffer、StringBuilder如何选择？</p><p>简述：已知字符串不会改变的情况使用String；字符串长度可变大部分情况使用StringBuilder；但是存在并发问题，可能存在多个线程都来修改共享数据时使用StringBuffer。</p></blockquote><p><strong>PS：INT显示宽度</strong></p><p>我们经常会使用命令来创建数据表，而且同时会指定一个长度，如下：</p><pre><code>CREATE TABLE `user`(    `id` TINYINT(2) UNSIGNED);</code></pre><p>这里表示user表的id字段的类型是TINYINT，可以存储的最大数值是255。如果存入值大于255，如500，那么MySQL会自动保存为TINYINT类型的最大值255。</p><p>在查询数据时，不管查询结果为何值，都按实际输出。这里TINYINT(2)中2的作用就是，当需要在查询结果前填充0时，命令中加上ZEROFILL就可以实现，如：</p><pre><code>`id` TINYINT(2) UNSIGNED ZEROFILL</code></pre><p>这样，查询结果如果是5，那输出就是05。如果指定TINYINT(5)，那输出就是00005，其实实际存储的值还是5，而且存储的数据不会超过255，只是MySQL输出数据时在前面填充了0。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-优化二</title>
      <link href="/posts/mysql-family/5/"/>
      <url>/posts/mysql-family/5/</url>
      
        <content type="html"><![CDATA[<h2 id="常见sql深入优化"><a href="#常见sql深入优化" class="headerlink" title="常见sql深入优化"></a>常见sql深入优化</h2><h3 id="Order-by与Group-by优化"><a href="#Order-by与Group-by优化" class="headerlink" title="Order by与Group by优化"></a><font color="red">Order by与Group by优化</font></h3><p>Case1：</p><p><img src="/images/mysql/opt2-1.png" alt="opt2-1"></p><p>分析： 利用最左前缀法则：中间字段不能断，因此查询用到了<strong>name索引</strong>，从key_len=74也能看出，age索引列用在<strong>排序</strong>过程中，因为Extra字段里<strong>没有using filesort</strong></p><span id="more"></span><p>Case2：</p><p><img src="/images/mysql/opt2-2.png" alt="opt2-2"></p><p>分析： 从explain的执行结果来看：key_len=74，查询使用了name索引，由于用了position进行排序，跳过了age，出现了<strong>Using filesort</strong>。</p><p><font color="red">小结：比较Case1和Case2，where+order不符合最左前缀法则 使用了文件排序</font></p><p>Case3：</p><p><img src="/images/mysql/opt2-3.png" alt="opt2-3"></p><p>分析： 查找只用到索引name，age和position用于排序，<strong>无Using filesort</strong>。</p><p>Case4：</p><p><img src="/images/mysql/opt2-4.png" alt="opt2-4"></p><p>分析： 和Case 3中explain的执行结果一样，但是出现了<strong>Using filesort</strong>，因为索引的创建顺序为 name,age,position，但是排序的时候age和position<strong>颠倒位置</strong>了。</p><p>Case5：</p><p><img src="/images/mysql/opt2-5.png" alt="opt2-5"></p><p>分析： 与Case 4对比，在Extra中并<strong>未出现Using filesort</strong>，因为<strong>age为常量</strong>，在排序中被优化，所以索引未颠倒， 不会出现Using filesort。</p><p>Case6：</p><p><img src="/images/mysql/opt2-6.png" alt="opt2-6"></p><p>分析： 虽然排序的字段列与索引顺序一样，且order by默认升序，这里position desc变成了降序，<strong>导致与索引的排序方式不同</strong>，从而产生Using filesort。Mysql8以上版本有降序索引可以支持该种查询方式。</p><p>Case7：</p><p><img src="/images/mysql/opt2-7.png" alt="opt2-7"></p><p>分析： 对于排序来说，多个相等条件也是范围查询。</p><p>Case8：</p><p><img src="/images/mysql/opt2-8.png" alt="opt2-8"></p><p><img src="/images/mysql/opt2-9.png" alt="opt2-9"></p><p>分析：范围查询可以用覆盖索引优化，注意where和order by的条件符合最左前缀法则。</p><h4 id="优化总结："><a href="#优化总结：" class="headerlink" title="优化总结："></a>优化总结：</h4><p>1、MySQL支持两种方式的排序<strong>filesort</strong>和<strong>index</strong>，Using index是指MySQL<strong>扫描索引本身完成排序</strong>。index效率高，filesort效率低。 </p><p>2、order by满足两种情况会使用Using index。</p><p>a) order by语句使用<strong>索引最左前列</strong>。 </p><p>b) 使用where子句与order by子句<strong>条件列组合满足索引最左前列</strong>。 </p><p>3、尽量在<strong>索引列</strong>上完成排序，遵循<strong>索引建立（索引创建的顺序）</strong>时的最左前缀法则。 </p><p>4、如果order by的条件不在索引列上，就会产生Using filesort。 </p><p>5、能用覆盖索引尽量用覆盖索引 </p><p>6、group by与order by很类似，其实质是<strong>先排序后分组</strong>，遵照<strong>索引创建顺序</strong>的最左前缀法则。对于group by的优化如果不需要排序的可以加上<strong>order by null</strong>禁止排序。注意，where高于having，能写在where中的限定条件就不要去having限定了。</p><h4 id="Using-filesort文件排序原理详解"><a href="#Using-filesort文件排序原理详解" class="headerlink" title="Using filesort文件排序原理详解"></a>Using filesort文件排序原理详解</h4><p><strong>filesort文件排序方式</strong> </p><ul><li><strong>单路排序</strong>：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt; </li><li><strong>双路排序（又叫回表排序模式）</strong>：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</li></ul><p>MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来判断使用哪种排序模式。 </p><ul><li>如果字段的总长度<strong>小于</strong>max_length_for_sort_data ，那么使用 <strong>单路排序模式</strong>； </li><li>如果字段的总长度<strong>大于</strong>max_length_for_sort_data ，那么使用 <strong>双路排序模式</strong>。</li></ul><p><font color="red">我的理解：sort buffer缓存大小有限，默认是1M，排序数据总长度小于max_length_for_sort_data时可以把全部字段放入缓存中排序，排序后直接返回给客户端；排序数据总长度超过max_length_for_sort_data时需要把排序字段和标识列（通常是主键）放入缓存中排序，排序完成通过标识列回表查到全部数据返回给客户端。</font></p><p>简单点就是：</p><p>数据总长度小于阈值，全部字段放入缓存排序，无需回表；</p><p>数据总长度大于阈值，排序字段和主键放入缓存排序（可以排序更多的列），但是需要回表。</p><p><strong>示例验证下各种排序方式：</strong></p><p><img src="/images/mysql/opt2-10.png" alt="opt2-10"></p><p>查看下这条sql对应trace结果如下(只展示排序部分)：</p><pre><code>"join_execution": {  --sql执行阶段    "select#": 1,    "steps": [      {        "filesort_information": [          {            "direction": "asc",            "table": "`employees`",            "field": "position"          }        ] /* filesort_information */,        "filesort_priority_queue_optimization": {          "usable": false,          "cause": "not applicable (no LIMIT)"        } /* filesort_priority_queue_optimization */,        "filesort_execution": [        ] /* filesort_execution */,        "filesort_summary": {  --文件排序信息          "rows": 0,  -- 预计扫描行数          "examined_rows": 0,  --参与扫描行数          "number_of_tmp_files": 0,  --使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的磁盘文件排序          "sort_buffer_size": 262080,  --排序缓存的大小，单位Byte          "sort_mode": "&lt;sort_key, packed_additional_fields&gt;"  --排序方式，单路排序        } /* filesort_summary */      }    ] /* steps */} /* join_execution */</code></pre><p>验证双路排序：</p><pre><code>-- 执行sql命令set session optimizer_trace="enabled=on";set max_length_for_sort_data = 10; -- 设置缓存大小，表中所有字段长度一定大于10字节select name,age,position from employees where name = 'gax' order by position;select * from information_schema.OPTIMIZER_TRACE;set session optimizer_trace="enabled=off";截取trace工具结果关键部分："filesort_summary": {    "rows": 0,    "examined_rows": 0,    "number_of_tmp_files": 0,    "sort_buffer_size": 262136,    "sort_mode": "&lt;sort_key, rowid&gt;" -- 双路排序} /* filesort_summary */</code></pre><p>总结单路排序：</p><p>根据查询条件找到满足条件的主键，依次根据主键查出整行，并把<strong>所有字段放入到sort_buffer</strong>中，在sort_buffer中按照order by的排序字段排好顺序，返回给客户端。</p><p>总结双路排序：</p><p>根据查询条件找到满足条件的主键，依次根据主键查出整行，并把<strong>主键和排序字段放入到sort_buffer</strong>中，在sort_buffer中根据排序字段对主键排好顺序，取出主键遍历，到<strong>原数据表</strong>中查出全部数据返回给客户端。</p><p>如果 MySQL <strong>排序内存 sort_buffer</strong> 配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用<strong>双路排序</strong>算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。 如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择全字段排序(<strong>单路排序</strong>)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。</p><p><strong>注意：</strong>如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。</p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a><font color="red"><strong>索引设计原则</strong></font></h3><p><strong>1. 代码先行，索引后上</strong> </p><p>一般应该等到主体业务功能开发完毕，把涉及到该表相关sql都要拿出来分析之后再建立索引。</p><p><strong>2. 联合索引尽量覆盖条件</strong> </p><p>可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的where、order by、group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则。</p><p><strong>3. 不要在小基数字段上建立索引</strong></p><p>一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分查找的优势来。</p><p><strong>4. 长字符串我们可以采用前缀索引</strong></p><p>尽量对字段类型较小的列设计索引，比如说什么tinyint之类的，因为字段类型较小的话，占用磁盘空间也会比较小，此时你在搜索的时候性能也会比较好一点。 </p><p>当然，这个所谓的字段类型小一点的列，也不是绝对的，很多时候你就是要针对varchar(255)这种字段建立索引，哪怕多占用一些磁盘空间也是有必要的。 </p><p>对于这种varchar(255)的大字段可能会比较占用磁盘空间，可以稍微优化下，比如针对这个字段的前20个字符建立索引，就是说对这个字段里的每个值的前20个字符放在索引树里，类似于 KEY index(name(20),age,position)。 </p><p>此时你在where条件里搜索的时候，如果是根据name字段来搜索，那么此时就会先到索引树里根据name字段的前20个字符去搜索，定位到之后前20个字符的前缀匹配的部分数据之后，再回到聚簇索引提取出来完整的name字段值进行比对。 </p><p>但是假如你要是order by name，那么此时你的name因为在索引树里仅仅包含了前20个字符，所以这个排序是没法用上索引的， group by也是同理。所以这里大家要对前缀索引有一个了解。</p><p><strong>5. where与order by冲突时优先where</strong> </p><p>一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序。 </p><p>因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，然后做排序的成本可能会小很多。</p><p><strong>6. 基于慢sql查询做优化</strong> </p><p>可以根据监控后台的一些慢sql，针对这些慢sql查询做特定的索引优化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-优化一</title>
      <link href="/posts/mysql-family/4/"/>
      <url>/posts/mysql-family/4/</url>
      
        <content type="html"><![CDATA[<p>预置表数据：</p><pre class=" language-java"><code class="language-java">CREATE TABLE `employees` <span class="token punctuation">(</span>    `id` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>    `name` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">24</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'姓名'</span><span class="token punctuation">,</span>    `age` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">'0'</span> COMMENT <span class="token string">'年龄'</span><span class="token punctuation">,</span>    `position` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'职位'</span><span class="token punctuation">,</span>    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="token string">'入职时间'</span><span class="token punctuation">,</span>    PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span> `id` <span class="token punctuation">)</span><span class="token punctuation">,</span>    KEY `idx_name_age_position` <span class="token punctuation">(</span> `name`<span class="token punctuation">,</span> `age`<span class="token punctuation">,</span> `position` <span class="token punctuation">)</span> USING BTREE <span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> INNODB AUTO_INCREMENT <span class="token operator">=</span> <span class="token number">4</span> DEFAULT CHARSET <span class="token operator">=</span> utf8 COMMENT <span class="token operator">=</span> <span class="token string">'员工记录表'</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'LiLei'</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'manager'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'HanMeimei'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>drop procedure <span class="token keyword">if</span> exists insert_emp<span class="token punctuation">;</span> delimiter <span class="token punctuation">;</span><span class="token punctuation">;</span>create procedure <span class="token function">insert_emp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        begin  declare i <span class="token keyword">int</span><span class="token punctuation">;</span>                      set i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                     insert into <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">)</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token function">CONCAT</span><span class="token punctuation">(</span><span class="token string">'gax'</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      set i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                         end <span class="token keyword">while</span><span class="token punctuation">;</span>end<span class="token punctuation">;</span><span class="token punctuation">;</span>delimiter <span class="token punctuation">;</span>call <span class="token function">insert_emp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><span id="more"></span><h2 id="举几个例子分析"><a href="#举几个例子分析" class="headerlink" title="举几个例子分析"></a>举几个例子分析</h2><p><strong>1. 联合索引第一个字段用范围</strong></p><p><img src="/images/mysql/opt-1.png" alt="opt-1"></p><p><img src="/images/mysql/opt-2.png" alt="opt-2"></p><p>我的理解：联合索引第一个字段使用范围查找时，后续联合索引列失效。MySQL根据自己的规则分析，以上第一条SQL查找结果略小于全表数据，MySQL认为全表扫描效率更高；第二条SQL查找的数据远远小于全表数据，MySQL认为使用索引查找效率更高。<font color="red">是否使用索引由MySQL决定，可以通过trace工具来查看，MySQL会选出全表扫描或索引查找中消耗更小的一个。</font></p><p><strong>2. 强制走索引</strong></p><p><img src="/images/mysql/opt-3.png" alt="opt-3"></p><p><img src="/images/mysql/opt-4.png" alt="opt-4"></p><p>对比以上两个SQL得到结论：虽然使用了强制走索引让联合索引第一个字段范围查找也走索引，扫描的行rows看上去也少了点，但是最终查找效率不一定比全表扫描高，因为回表效率不高。<font color="red">不建议强制使用索引，由MySQL默认选择即可</font></p><p><strong>3. 覆盖索引优化</strong></p><p><img src="/images/mysql/opt-5.png" alt="opt-5"></p><p>对于上面范围查找使用全表扫描的情况，可以使用<strong>覆盖索引</strong>优化，结果数据在联合索引的索引树上可以直接找到，<strong>不需要回表</strong>查找</p><p><strong>4. in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描</strong></p><p><img src="/images/mysql/opt-6.png" alt="opt-6"></p><p><img src="/images/mysql/opt-7.png" alt="opt-7"></p><p><img src="/images/mysql/opt-8.png" alt="opt-8"></p><p><img src="/images/mysql/opt-9.png" alt="opt-9"></p><p>将employees 表复制一张employees_copy的表，里面保留三条记录，可以验证第4点</p><pre class=" language-java"><code class="language-java">CREATE TABLE `employees_copy` <span class="token punctuation">(</span>    `id` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>    `name` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">24</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'姓名'</span><span class="token punctuation">,</span>    `age` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">'0'</span> COMMENT <span class="token string">'年龄'</span><span class="token punctuation">,</span>    `position` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'职位'</span><span class="token punctuation">,</span>    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="token string">'入职时间'</span><span class="token punctuation">,</span>    PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span> `id` <span class="token punctuation">)</span><span class="token punctuation">,</span>    KEY `idx_name_age_position` <span class="token punctuation">(</span> `name`<span class="token punctuation">,</span> `age`<span class="token punctuation">,</span> `position` <span class="token punctuation">)</span> USING BTREE <span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> INNODB AUTO_INCREMENT <span class="token operator">=</span> <span class="token number">4</span> DEFAULT CHARSET <span class="token operator">=</span> utf8 COMMENT <span class="token operator">=</span> <span class="token string">'员工记录表'</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees_copy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'LiLei'</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'manager'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees_copy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'HanMeimei'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees_copy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>5. like KK% 一般情况都会走索引</strong></p><p><img src="/images/mysql/opt-10.png" alt="opt-10"></p><p><img src="/images/mysql/opt-11.png" alt="opt-11"></p><p>注意：这里的模糊查询<strong>like 后面不是以通配符开始</strong>的</p><p>这里补充一个概念，<strong>索引下推（Index Condition Pushdown，ICP）</strong>, like KK%其实就是用到了索引下推优化</p><h3 id="什么是索引下推了？"><a href="#什么是索引下推了？" class="headerlink" title="什么是索引下推了？"></a>什么是索引下推了？</h3><p>对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，<strong>SELECT * FROM employees WHERE name like ‘LiLei%’ AND age = 22 AND position =’manager’</strong>  这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和position是无序的，无法很好的利用索引。</p><p>在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。</p><p>MySQL 5.6引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数</strong>。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</p><p>索引下推会<strong>减少回表次数</strong>，对于<strong>innodb引擎的表索引下推只能用于二级索引</strong>，innodb的主键索引（聚簇索引）树叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p><p><strong>为什么范围查找Mysql没有用索引下推优化？</strong></p><p>估计应该是MySQL认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里MySQL选择给 like KK% 用了索引下推优化，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p><h2 id="Mysql如何选择合适的索引"><a href="#Mysql如何选择合适的索引" class="headerlink" title="Mysql如何选择合适的索引"></a>Mysql如何选择合适的索引</h2><p><img src="/images/mysql/opt-12.png" alt="opt-12"></p><p><img src="/images/mysql/opt-13.png" alt="opt-13"></p><p><img src="/images/mysql/opt-14.png" alt="opt-14"></p><p>总结：如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果。</p><p>另外对于上面这两种 name&gt;’a’ 和 name&gt;’zzz’ 的执行结果，mysql最终是否选择走索引或者一张表涉及多个索引，mysql最终如何选择索引，我们可以用<strong>trace工具</strong>来一查究竟，开启trace工具会影响mysql性能，所以只能临时分析sql使用，用完之后立即关闭。</p><h3 id="trace工具用法："><a href="#trace工具用法：" class="headerlink" title="trace工具用法："></a>trace工具用法：</h3><p><img src="/images/mysql/opt-15.png" alt="opt-15"></p><p>注意：上图第二步两条SQL要一起执行，才能得到分析后的<strong>TRACE</strong>，TRACE分析如下：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"join_preparation"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 第一阶段：SQL准备 格式化SQL        <span class="token string">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token string">"expanded_query"</span><span class="token operator">:</span> <span class="token string">"/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` > 'a') order by `employees`.`position`"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span>      <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* join_preparation */</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token string">"join_optimization"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 第二阶段：SQL优化阶段        <span class="token string">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token string">"condition_processing"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 条件处理              <span class="token string">"condition"</span><span class="token operator">:</span> <span class="token string">"WHERE"</span><span class="token punctuation">,</span>              <span class="token string">"original_condition"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span><span class="token punctuation">,</span>              <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                  <span class="token string">"transformation"</span><span class="token operator">:</span> <span class="token string">"equality_propagation"</span><span class="token punctuation">,</span>                  <span class="token string">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                  <span class="token string">"transformation"</span><span class="token operator">:</span> <span class="token string">"constant_propagation"</span><span class="token punctuation">,</span>                  <span class="token string">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                  <span class="token string">"transformation"</span><span class="token operator">:</span> <span class="token string">"trivial_condition_removal"</span><span class="token punctuation">,</span>                  <span class="token string">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span>                <span class="token punctuation">}</span>              <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* condition_processing */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"substitute_generated_columns"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* substitute_generated_columns */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"table_dependencies"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token operator">--</span> 表依赖详情              <span class="token punctuation">{</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                <span class="token string">"row_may_be_null"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token string">"map_bit"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token string">"depends_on_map_bits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* depends_on_map_bits */</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* table_dependencies */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"ref_optimizer_key_uses"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* ref_optimizer_key_uses */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"rows_estimation"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token operator">--</span> 预估表的访问成本              <span class="token punctuation">{</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                <span class="token string">"range_analysis"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                  <span class="token string">"table_scan"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 全表扫描情况                    <span class="token string">"rows"</span><span class="token operator">:</span> <span class="token number">99988</span><span class="token punctuation">,</span> <span class="token operator">--</span> 扫描行数                    <span class="token string">"cost"</span><span class="token operator">:</span> <span class="token number">20289</span>  <span class="token operator">--</span> 查询成本                  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* table_scan */</span><span class="token punctuation">,</span>                  <span class="token string">"potential_range_indexes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token operator">--</span> 查询可能使用的索引                    <span class="token punctuation">{</span>                      <span class="token string">"index"</span><span class="token operator">:</span> <span class="token string">"PRIMARY"</span><span class="token punctuation">,</span>  <span class="token operator">--</span> 主键索引                      <span class="token string">"usable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                      <span class="token string">"cause"</span><span class="token operator">:</span> <span class="token string">"not_applicable"</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                      <span class="token string">"index"</span><span class="token operator">:</span> <span class="token string">"idx_name_age_position"</span><span class="token punctuation">,</span>  <span class="token operator">--</span> 辅助索引                      <span class="token string">"usable"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                      <span class="token string">"key_parts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                        <span class="token string">"name"</span><span class="token punctuation">,</span>                        <span class="token string">"age"</span><span class="token punctuation">,</span>                        <span class="token string">"position"</span><span class="token punctuation">,</span>                        <span class="token string">"id"</span>                      <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* key_parts */</span>                    <span class="token punctuation">}</span>                  <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* potential_range_indexes */</span><span class="token punctuation">,</span>                  <span class="token string">"setup_range_conditions"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                  <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* setup_range_conditions */</span><span class="token punctuation">,</span>                  <span class="token string">"group_index_range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token string">"chosen"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                    <span class="token string">"cause"</span><span class="token operator">:</span> <span class="token string">"not_group_by_or_distinct"</span>                  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* group_index_range */</span><span class="token punctuation">,</span>                  <span class="token string">"analyzing_range_alternatives"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 分析各个索引使用成本                    <span class="token string">"range_scan_alternatives"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                      <span class="token punctuation">{</span>                        <span class="token string">"index"</span><span class="token operator">:</span> <span class="token string">"idx_name_age_position"</span><span class="token punctuation">,</span>                        <span class="token string">"ranges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                          <span class="token string">"a &lt; name"</span>  <span class="token operator">--</span> 索引使用范围                        <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* ranges */</span><span class="token punctuation">,</span>                        <span class="token string">"index_dives_for_eq_ranges"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token string">"rowid_ordered"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token operator">--</span> 使用该索引获取的记录是否按照主键排序                        <span class="token string">"using_mrr"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                        <span class="token string">"index_only"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>     <span class="token operator">--</span> 是否覆盖索引                        <span class="token string">"rows"</span><span class="token operator">:</span> <span class="token number">49994</span><span class="token punctuation">,</span>           <span class="token operator">--</span> 索引扫描行数                        <span class="token string">"cost"</span><span class="token operator">:</span> <span class="token number">59994</span><span class="token punctuation">,</span>           <span class="token operator">--</span> 索引使用成本                        <span class="token string">"chosen"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>         <span class="token operator">--</span> 是否选择该索引                        <span class="token string">"cause"</span><span class="token operator">:</span> <span class="token string">"cost"</span>                      <span class="token punctuation">}</span>                    <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* range_scan_alternatives */</span><span class="token punctuation">,</span>                    <span class="token string">"analyzing_roworder_intersect"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                      <span class="token string">"usable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                      <span class="token string">"cause"</span><span class="token operator">:</span> <span class="token string">"too_few_roworder_scans"</span>                    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* analyzing_roworder_intersect */</span>                  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* analyzing_range_alternatives */</span>                <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* range_analysis */</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* rows_estimation */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"considered_execution_plans"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token string">"plan_prefix"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* plan_prefix */</span><span class="token punctuation">,</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                <span class="token string">"best_access_path"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 最优访问路径                  <span class="token string">"considered_access_paths"</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token operator">--</span> 考虑<span class="token operator">/</span>最终选择的访问路径                    <span class="token punctuation">{</span>                      <span class="token string">"rows_to_scan"</span><span class="token operator">:</span> <span class="token number">99988</span><span class="token punctuation">,</span>                      <span class="token string">"access_type"</span><span class="token operator">:</span> <span class="token string">"scan"</span><span class="token punctuation">,</span>  <span class="token operator">--</span> 访问类型，全表扫描                      <span class="token string">"resulting_rows"</span><span class="token operator">:</span> <span class="token number">99988</span><span class="token punctuation">,</span>                      <span class="token string">"cost"</span><span class="token operator">:</span> <span class="token number">20287</span><span class="token punctuation">,</span>                      <span class="token string">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>         <span class="token operator">--</span> 确认选择                      <span class="token string">"use_tmp_table"</span><span class="token operator">:</span> <span class="token boolean">true</span>                    <span class="token punctuation">}</span>                  <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* considered_access_paths */</span>                <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* best_access_path */</span><span class="token punctuation">,</span>                <span class="token string">"condition_filtering_pct"</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>                <span class="token string">"rows_for_plan"</span><span class="token operator">:</span> <span class="token number">99988</span><span class="token punctuation">,</span>                <span class="token string">"cost_for_plan"</span><span class="token operator">:</span> <span class="token number">20287</span><span class="token punctuation">,</span>                <span class="token string">"sort_cost"</span><span class="token operator">:</span> <span class="token number">99988</span><span class="token punctuation">,</span>                <span class="token string">"new_cost_for_plan"</span><span class="token operator">:</span> <span class="token number">120275</span><span class="token punctuation">,</span>                <span class="token string">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* considered_execution_plans */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"attaching_conditions_to_tables"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"original_condition"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span><span class="token punctuation">,</span>              <span class="token string">"attached_conditions_computation"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* attached_conditions_computation */</span><span class="token punctuation">,</span>              <span class="token string">"attached_conditions_summary"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                  <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                  <span class="token string">"attached"</span><span class="token operator">:</span> <span class="token string">"(`employees`.`name` > 'a')"</span>                <span class="token punctuation">}</span>              <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* attached_conditions_summary */</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* attaching_conditions_to_tables */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"clause_processing"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"clause"</span><span class="token operator">:</span> <span class="token string">"ORDER BY"</span><span class="token punctuation">,</span>              <span class="token string">"original_clause"</span><span class="token operator">:</span> <span class="token string">"`employees`.`position`"</span><span class="token punctuation">,</span>              <span class="token string">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                  <span class="token string">"item"</span><span class="token operator">:</span> <span class="token string">"`employees`.`position`"</span>                <span class="token punctuation">}</span>              <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* items */</span><span class="token punctuation">,</span>              <span class="token string">"resulting_clause_is_simple"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>              <span class="token string">"resulting_clause"</span><span class="token operator">:</span> <span class="token string">"`employees`.`position`"</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* clause_processing */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"reconsidering_access_paths_for_index_ordering"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"clause"</span><span class="token operator">:</span> <span class="token string">"ORDER BY"</span><span class="token punctuation">,</span>              <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span><span class="token punctuation">,</span>              <span class="token string">"index_order_summary"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                <span class="token string">"index_provides_order"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token string">"order_direction"</span><span class="token operator">:</span> <span class="token string">"undefined"</span><span class="token punctuation">,</span>                <span class="token string">"index"</span><span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span>                <span class="token string">"plan_changed"</span><span class="token operator">:</span> <span class="token boolean">false</span>              <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* index_order_summary */</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* reconsidering_access_paths_for_index_ordering */</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"refine_plan"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* refine_plan */</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span>      <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* join_optimization */</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token string">"join_execution"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token operator">--</span> 第三阶段：SQL执行阶段        <span class="token string">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token string">"filesort_information"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token string">"direction"</span><span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">,</span>                <span class="token string">"table"</span><span class="token operator">:</span> <span class="token string">"`employees`"</span><span class="token punctuation">,</span>                <span class="token string">"field"</span><span class="token operator">:</span> <span class="token string">"position"</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* filesort_information */</span><span class="token punctuation">,</span>            <span class="token string">"filesort_priority_queue_optimization"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"usable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>              <span class="token string">"cause"</span><span class="token operator">:</span> <span class="token string">"not applicable (no LIMIT)"</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* filesort_priority_queue_optimization */</span><span class="token punctuation">,</span>            <span class="token string">"filesort_execution"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* filesort_execution */</span><span class="token punctuation">,</span>            <span class="token string">"filesort_summary"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"rows"</span><span class="token operator">:</span> <span class="token number">100003</span><span class="token punctuation">,</span>              <span class="token string">"examined_rows"</span><span class="token operator">:</span> <span class="token number">100003</span><span class="token punctuation">,</span>              <span class="token string">"number_of_tmp_files"</span><span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>              <span class="token string">"sort_buffer_size"</span><span class="token operator">:</span> <span class="token number">262016</span><span class="token punctuation">,</span>              <span class="token string">"sort_mode"</span><span class="token operator">:</span> <span class="token string">"&lt;sort_key, packed_additional_fields>"</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* filesort_summary */</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span>      <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* join_execution */</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">/* steps */</span><span class="token punctuation">}</span></code></pre><p>结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描  </p><p>注意：trace分析中的cost消耗是关键，MySQL会选择消耗小的方案去执行。cost分数是MySQL根据内部算法得到的，并非真正的执行一遍SQL获取数据。</p><p>找到一个不错的总结：（参考自文章：<a href="https://www.modb.pro/db/409873">MySQL之explain extra字段解析 - 墨天轮 (modb.pro)</a>）</p><table><thead><tr><th align="left">extra</th><th align="center">where条件</th><th align="center">select的字段</th></tr></thead><tbody><tr><td align="left">null</td><td align="center">where筛选条件是索引的前导列</td><td align="center">查询的列未被索引覆盖</td></tr><tr><td align="left">Using index</td><td align="center">where筛选条件是索引的前导列</td><td align="center">查询的列被索引覆盖</td></tr><tr><td align="left">Using where; Using index</td><td align="center">where筛选条件是索引列之一但不是前导列或者where筛选条件是索引列前导列的一个范围</td><td align="center">查询的列被索引覆盖</td></tr><tr><td align="left">Using where;</td><td align="center">where筛选条件不是索引列</td><td align="center">-</td></tr><tr><td align="left">Using where;</td><td align="center">where筛选条件不是索引前导列、是索引列前导列的一个范围</td><td align="center">查询列未被索引覆盖</td></tr><tr><td align="left">Using index condition</td><td align="center">where索引列前导列的一个范围</td><td align="center">查询列未被索引覆盖</td></tr></tbody></table><p>注意：这里<strong>where索引列前导列的一个范围，可能是Using where; 也可能是Using index condition</strong></p><table><thead><tr><th align="left">extra</th><th align="center">出现场景</th></tr></thead><tbody><tr><td align="left">Using filesort</td><td align="center">filesort主要用于查询数据结果集的排序操作，首先MySQL会使用sort_buffer_size大小的内存进行排序，如果结果集超过了sort_buffer_size大小，会把这一个排序后的chunk转移到file上，最后使用多路归并排序完成所有数据的排序操作。</td></tr><tr><td align="left">Using temporary</td><td align="center">MySQL使用临时表保存临时的结构，以用于后续的处理，MySQL首先创建heap引擎的临时表，如果临时的数据过多，超过max_heap_table_size的大小，会自动把临时表转换成MyISAM引擎的表来使用。</td></tr></tbody></table><p>两者的不同：<br>filesort只能应用在<strong>单个表</strong>上，如果有<strong>多个表</strong>的数据需要排序，那么MySQL会先使用using temporary保存临时数据，然后再在临时表上使用filesort进行排序，最后输出结果。</p><p><strong>什么是索引前导列</strong></p><p>所谓前导列，就是在创建复合索引语句的第一列或者连续的多列。比如通过：CREATE INDEX idx_combine ON table_a(x, y, z)创建索引，那么x,xy,xyz都是前导列，而yz，y，z这样的就不是。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引优化实践</title>
      <link href="/posts/mysql-family/3/"/>
      <url>/posts/mysql-family/3/</url>
      
        <content type="html"><![CDATA[<p>预置表数据：</p><pre class=" language-java"><code class="language-java">CREATE TABLE `employees` <span class="token punctuation">(</span>    `id` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>    `name` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">24</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'姓名'</span><span class="token punctuation">,</span>    `age` <span class="token function">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">'0'</span> COMMENT <span class="token string">'年龄'</span><span class="token punctuation">,</span>    `position` <span class="token function">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> NOT NULL DEFAULT <span class="token string">''</span> COMMENT <span class="token string">'职位'</span><span class="token punctuation">,</span>    `hire_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="token string">'入职时间'</span><span class="token punctuation">,</span>    PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span> `id` <span class="token punctuation">)</span><span class="token punctuation">,</span>    KEY `idx_name_age_position` <span class="token punctuation">(</span> `name`<span class="token punctuation">,</span> `age`<span class="token punctuation">,</span> `position` <span class="token punctuation">)</span> USING BTREE <span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> INNODB AUTO_INCREMENT <span class="token operator">=</span> <span class="token number">4</span> DEFAULT CHARSET <span class="token operator">=</span> utf8 COMMENT <span class="token operator">=</span> <span class="token string">'员工记录表'</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'LiLei'</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'manager'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'HanMeimei'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT INTO <span class="token function">employees</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position<span class="token punctuation">,</span>hire_time<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">'dev'</span><span class="token punctuation">,</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><span id="more"></span><p><strong>1. 全值匹配</strong></p><p>查询条件 = 确切的值</p><p><img src="/images/mysql/idx-1.png" alt="idx-1"></p><p><img src="/images/mysql/idx-2.png" alt="idx-2"></p><p><img src="/images/mysql/idx-3.png" alt="idx-3"></p><p>根据key_len计算规则：</p><p>字符串类型varchar(n)：如果存汉字则长度是 3n + 2 字节</p><p>数值类型int：4字节</p><p>name：<code>24*3+2 = 74</code>字节，age：<code>4</code>字节，position：<code>20*3+2 = 62</code>字节</p><p><strong>2. 最左前缀法则</strong></p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p><img src="/images/mysql/idx-4.png" alt="idx-4"></p><p><img src="/images/mysql/idx-5.png" alt="idx-5"></p><p><img src="/images/mysql/idx-6.png" alt="idx-6"></p><p>总结：查询1满足最左前列法则可以使用索引，查询2和3跳过索引中的列查询导致索引失效</p><p><strong>3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></p><p><img src="/images/mysql/idx-7.png" alt="idx-7"></p><p><img src="/images/mysql/idx-8.png" alt="idx-8"></p><p>转化为日期范围查询，有可能会走索引：</p><p><img src="/images/mysql/idx-9.png" alt="idx-9"></p><p>总结：查询语句是否走索引和索引的结构息息相关，<strong>排好序</strong></p><p><strong>4. 存储引擎不能使用索引中范围条件右边的列</strong></p><p><img src="/images/mysql/idx-10.png" alt="idx-10"></p><p><strong>5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong></p><p><img src="/images/mysql/idx-11.png" alt="idx-11"></p><p><strong>6. MySQL在使用不等于（!=或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描 &lt; 小于、 &gt; 大于、 &lt;=、&gt;= 这些，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</strong></p><p><img src="/images/mysql/idx-12.png" alt="idx-12"></p><p><strong>7. is null,is not null 一般情况下也无法使用索引</strong></p><p><img src="/images/mysql/idx-13.png" alt="idx-13"></p><p><strong>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong></p><p><img src="/images/mysql/idx-14.png" alt="idx-14"></p><p><img src="/images/mysql/idx-15.png" alt="idx-15"></p><p>问题：解决like’%字符串%’索引不被使用的方法？ </p><p>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p><p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p><p><strong>9. 字符串不加单引号索引失效</strong></p><p><img src="/images/mysql/idx-16.png" alt="idx-16"></p><p><strong>10. 少用or或in，用它查询时，MySQL不一定使用索引，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估 是否使用索引，详见范围查询优化</strong></p><p><img src="/images/mysql/idx-17.png" alt="idx-17"></p><p><strong>11. 范围查询优化</strong></p><p><img src="/images/mysql/idx-18.png" alt="idx-18"></p><p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由 于单次数据量查询过大导致优化器最终选择不走索引 </p><p>优化方法：可以将大的范围拆分成多个小范围</p><p><img src="/images/mysql/idx-19.png" alt="idx-19"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-Explain</title>
      <link href="/posts/mysql-family/2/"/>
      <url>/posts/mysql-family/2/</url>
      
        <content type="html"><![CDATA[<h2 id="Explain工具是什么？"><a href="#Explain工具是什么？" class="headerlink" title="Explain工具是什么？"></a>Explain工具是什么？</h2><p>是MySQL提供的工具，在select前添加explain关键字，会返回执行计划信息，而不是执行SQL</p><p>可以用来分析SQL的执行情况，比如使用哪些索引，扫描哪些行…</p><p>注意：如果from包含子查询，仍会执行该子查询，查询结果放入到临时表中</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">Explain官网入口</a></p><span id="more"></span><p>辅助学习理解预置表数据：</p><pre class=" language-java"><code class="language-java">DROP TABLE IF EXISTS `actor`<span class="token punctuation">;</span>CREATE TABLE `actor` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`name` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>`update_time` datetime DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `actor` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `name`<span class="token punctuation">,</span> `update_time`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DROP TABLE IF EXISTS `film`<span class="token punctuation">;</span>CREATE TABLE `film` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT<span class="token punctuation">,</span>`name` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>KEY `idx_name` <span class="token punctuation">(</span>`name`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `film` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `name`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'film0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'film1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'film2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DROP TABLE IF EXISTS `film_actor`<span class="token punctuation">;</span>CREATE TABLE `film_actor` <span class="token punctuation">(</span>`id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`film_id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`actor_id` <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span>`remark` <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> DEFAULT NULL<span class="token punctuation">,</span>PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>KEY `idx_film_actor_id` <span class="token punctuation">(</span>`film_id`<span class="token punctuation">,</span>`actor_id`<span class="token punctuation">)</span><span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>InnoDB DEFAULT CHARSET<span class="token operator">=</span>utf8<span class="token punctuation">;</span>INSERT INTO `film_actor` <span class="token punctuation">(</span>`id`<span class="token punctuation">,</span> `film_id`<span class="token punctuation">,</span> `actor_id`<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Explain怎么用？"><a href="#Explain怎么用？" class="headerlink" title="Explain怎么用？"></a>Explain怎么用？</h2><p>在select查询语句前面加上<code>explain</code>关键字即可，sql语句中每有一个select关键字就会输出一行类似执行计划的信息</p><p><img src="/images/mysql/explain-1.png" alt="explain-1"></p><p><img src="/images/mysql/explain-2.png" alt="explain-2"></p><p><strong>explain 两个变种</strong></p><p>a) <strong>explain extended</strong>：额外提供一些优化信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个百分比的值，rows * filtered/100 可以<strong>估算出将要和 explain 中前一个表进行连接的行数</strong>（前一个表指 explain 中的id值比当前表id值小的表，id值越大执行的优先级越高，id相同从上往下执行，注意这里的id并非主键）</p><p>b) <strong>explain partitions</strong>：多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分 区</p><p>我的MySQL5.7版本添加explain默认展示了filtered 和partitions 列，extended和partitions关键字未来版本可能会被移除</p><p>explain输出结果每一列的含义，截取官网描述如下：</p><p><strong>Table 8.1 EXPLAIN Output Columns</strong></p><table><thead><tr><th align="left">Column</th><th align="left">JSON Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id"><code>id</code></a></td><td align="left"><code>select_id</code></td><td align="left">The <code>SELECT</code> identifier</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type"><code>select_type</code></a></td><td align="left">None</td><td align="left">The <code>SELECT</code> type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table"><code>table</code></a></td><td align="left"><code>table_name</code></td><td align="left">The table for the output row</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions"><code>partitions</code></a></td><td align="left"><code>partitions</code></td><td align="left">The matching partitions</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type"><code>type</code></a></td><td align="left"><code>access_type</code></td><td align="left">The join type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td><td align="left"><code>possible_keys</code></td><td align="left">The possible indexes to choose</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key"><code>key</code></a></td><td align="left"><code>key</code></td><td align="left">The index actually chosen</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len"><code>key_len</code></a></td><td align="left"><code>key_length</code></td><td align="left">The length of the chosen key</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref"><code>ref</code></a></td><td align="left"><code>ref</code></td><td align="left">The columns compared to the index</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows"><code>rows</code></a></td><td align="left"><code>rows</code></td><td align="left">Estimate of rows to be examined</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered"><code>filtered</code></a></td><td align="left"><code>filtered</code></td><td align="left">Percentage of rows filtered by table condition</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra"><code>Extra</code></a></td><td align="left">None</td><td align="left">Additional information</td></tr></tbody></table><h2 id="explain中的列详细介绍"><a href="#explain中的列详细介绍" class="headerlink" title="explain中的列详细介绍"></a>explain中的列详细介绍</h2><p><strong>1. id列</strong> </p><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><p><strong>2. select_type列</strong></p><p> select_type 表示对应行是简单还是复杂的查询。</p><p><img src="/images/mysql/explain-3.png" alt="explain-3"></p><p>1）simple：简单查询。查询不包含子查询和union </p><p>2）primary：复杂查询中最外层的 select </p><p>3）subquery：包含在 select 中的子查询（不在 from 子句中） </p><p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表</p><p>5）union：在 union 中的第二个和随后的 select</p><p><img src="/images/mysql/explain-4.png" alt="explain-4"></p><p><strong>3. table列</strong> </p><p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是<code>&lt;derivenN&gt;</code>格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 当有 union 时，UNION RESULT 的 table 列的值为<code>&lt;union1,2&gt;</code>，1和2表示参与 union 的 select 行id。</p><p><strong>4. partitions列</strong> </p><p>如果查询是基于分区表的话，partitions 字段会显示查询将访问的分区。</p><p><strong>5. type列</strong> </p><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p><p>依次从最优到最差分别为：<font color="red">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</font> </p><p>一般来说，<font color="red">得保证查询达到range级别，最好达到ref </font></p><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表（目标数据在主键索引树和二级索引树同时存在时，优先用二级索引树去查，因为二级索引树没有保存全部数据，更轻量效率高）</p><p><img src="/images/mysql/explain-5.png" alt="explain-5"></p><p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量。用于 primary key 或 unique key 的所有列与常数比较时，所有表最多有一个匹配行，读取1次速度比较快。</p><p><strong>system是 const的特例</strong>，表里只有一条记录匹配时为system</p><p><img src="/images/mysql/explain-6.png" alt="explain-6"></p><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p><p><img src="/images/mysql/explain-7.png" alt="explain-7"></p><p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><p>简单 select 查询，name是普通索引（非唯一索引）：</p><p><img src="/images/mysql/explain-8.png" alt="explain-8"></p><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分：</p><p><img src="/images/mysql/explain-9.png" alt="explain-9"></p><p><strong>range</strong>：范围扫描通常出现在 <code>in(), between ,&gt; ,&lt;, &gt;=</code> 等操作中。使用一个索引来检索给定范围的行。</p><p><img src="/images/mysql/explain-10.png" alt="explain-10"></p><p><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</p><p><img src="/images/mysql/explain-11.png" alt="explain-11"></p><p><strong>ALL</strong>：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化。</p><p><img src="/images/mysql/explain-12.png" alt="explain-12"></p><p><strong>6. possible_keys列</strong></p><p>这一列显示查询可能使用哪些索引来查找。 </p><p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </p><p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p><p> <strong>7.key列</strong> </p><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><p><strong>8.key_len列</strong> </p><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p><p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><p><img src="/images/mysql/explain-13.png" alt="explain-13"></p><p>key_len计算规则如下： </p><ul><li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数</strong>，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节 </p></li><li><ul><li>char(n)：如果存汉字长度就是 3n 字节</li></ul></li><li><ul><li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</li></ul></li><li><p>数值类型 </p></li><li><ul><li>tinyint：1字节 </li><li>smallint：2字节 </li><li>int：4字节 </li><li>bigint：8字节</li></ul></li></ul><p>　</p><ul><li><p>时间类型　 </p></li><li><ul><li>date：3字节 </li><li>timestamp：4字节</li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索 引。</p><p><strong>9. ref列</strong> </p><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p><p><strong>10. rows列</strong> </p><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </p><p><strong>11.filtered 列</strong> </p><p>该列是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p><p><strong>12. Extra列</strong> </p><p>这一列展示的是额外信息。常见的重要值如下： </p><p>1）<strong>Using index：</strong>使用覆盖索引 </p><p>覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p><p><img src="/images/mysql/explain-14.png" alt="explain-14"></p><p>2）<strong>Using where：</strong>使用 where 语句来处理结果，并且查询的列未被索引覆盖</p><p><img src="/images/mysql/explain-15.png" alt="explain-15"></p><p>3）<strong>Using index condition：</strong>查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p><p><img src="/images/mysql/explain-16.png" alt="explain-16"></p><p>4）<strong>Using temporary：</strong>mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ol><li><p>actor.name没有索引，此时创建了张临时表来distinct</p><p><img src="/images/mysql/explain-17.png" alt="explain-17"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</p><p><img src="/images/mysql/explain-18.png" alt="explain-18"></p></li></ol><p>5）<strong>Using filesort：</strong>将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p><p><img src="/images/mysql/explain-19.png" alt="explain-19"></p></li><li><p>film.name建立了idx_name索引,此时查询时extra是using index</p><p><img src="/images/mysql/explain-20.png" alt="explain-20"></p></li></ol><p>6）<strong>Select tables optimized away：</strong>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</p><p><img src="/images/mysql/explain-21.png" alt="explain-21"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引篇</title>
      <link href="/posts/mysql-family/1/"/>
      <url>/posts/mysql-family/1/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要学习MySQL？"><a href="#为什么要学习MySQL？" class="headerlink" title="为什么要学习MySQL？"></a>为什么要学习MySQL？</h4><p>目前互联网公司多数都在使用，MySQL的数据结构和一些设计思想很值得学习，面试必问…</p><p>思考：生产上遇到的慢查询/慢SQL查询，解决方法通常是添加索引，添加索引后查询速度可以提升几个数量级怎么做到的？正常一条SQL执行速度是几十毫秒或者几百毫秒，慢SQL执行几秒甚至几十秒肯定是不合理的。</p><p>想要学好MySQL首先要理解<code>索引</code>的概念，索引可以帮助MySQL高效查找数据，是一个<font color="red">排好序</font>的<font color="red">数据结构</font>（排好序体现在从左到右依次递增）。</p><p>国外的一个数据结构图示化网址：<a href="https://www.cs.usfca.edu/~galles/visualization/">https://www.cs.usfca.edu/~galles/visualization/</a></p><span id="more"></span><h4 id="索引的数据结构有很多："><a href="#索引的数据结构有很多：" class="headerlink" title="索引的数据结构有很多："></a>索引的数据结构有很多：</h4><ul><li>二叉树</li></ul><p>也叫折半查找，可以快速定位到数据。特点是右子节点的数据一定大于父节点的数据，左子节点的数据一定小于父节点的数据。缺点是由于每个节点只保存单个数据，所以数据量越大树的高度就会越高，查询次数越多查询效率会变低，极端情况例如所有数据都在节点的同一侧，查询类似逐行查找效率很低。</p><p><img src="/images/mysql/BinarySearchTree.png" alt="Binary Search Tree"></p><ul><li>红黑树</li></ul><p>也叫二叉平衡树，在二叉树的基础上做了优化。当节点左右两侧树的高度相差较多时自动做平衡，可以提高一定的查询性能，同时在平衡过程中会带来一定的消耗（左旋右旋等）。数据量大时，同样有树的高度变高导致查询次数多而效率低的问题。Hashmap在1.8版本做了优化，数据结构改为数组＋链表和红黑树，后续再做详细总结。</p><p><img src="/images/mysql/RedBlackTree.png" alt="Red/Black Tree"></p><ul><li>hash</li></ul><p>对于等值查询支持良好，不支持范围查找。对索引键做hash运算后维护到hash表（hash表中保存磁盘文件的地址）中，并关联到数据在磁盘中的地址，可以一次快速查找到目标数据。MySQL实现了自己的hash算法（常见的MD5、CRC16、CRC32等都是hash算法），发生hash冲突时数据在hash桶后面追加。</p><ul><li>B-树</li></ul><p>思考：在红黑树的基础上，横向保存的节点越多，是不是就意味着树的高度越低？</p><p>单个节点可以保存更多的数据。数据量大时，可以明显的降低树的高度，减少查询次数从而提高性能。</p><p>特点：叶子节点具有相同的深度，且指针为空；所有索引元素不重复；节点的数据索引左到右依次递增。</p><p><img src="/images/mysql/BTrees.png" alt="B Trees"></p><p>MySQL的B-树：</p><p><img src="/images/mysql/MySQLBTree.png" alt="MySQL B Trees"></p><ul><li>B+树</li></ul><p>MySQL索引没有选择纯粹的B-树，而是对其进行优化，使用B＋树（B-树变种）作为底层的数据结构，B＋树这种数据结构数据量越大性能提升的越明显。</p><p>B＋树的叶子节点（磁盘页）保存着多条索引和数据，把每个叶子节点上的第一个索引提取出来作为冗余保存在非叶子节点中，非叶子节点大小固定且只保存索引（严格上还有和叶子节点关联的指针），非叶子节点保存更多的索引理论上就代表可以保存更多的数据。</p><p>特点：非叶子节点不存储data，只保存冗余索引，可保存更多索引；叶子节点包含所有索引字段；叶子节点用指针连接，提高区间访问性能。</p><p><img src="/images/mysql/B+Trees.png" alt="B+Trees"></p><p>MySQL的B+树：</p><p><img src="/images/mysql/MySQLB+Trees.png" alt="MySQL B+Trees"></p><p>MySQL对B+树同样做了优化：叶子节点间使用的是双向指针，B+树原本使用的是单向指针</p><p>B＋树相对B-树做了哪些优化？</p><p>a）B＋树的非叶子节点只保存索引，而B-树的非叶子节点保存索引和数据。B+树的叶子节点包含所有的索引元素</p><p>b）B＋树相邻的叶子节点之间有双向的指针，保存相邻节点的磁盘地址，范围查找更友好</p><p>补充：MySQL的数据是保存在磁盘中，存储位置在磁盘中随机，取决于写数据时通过磁道写入的磁盘位置。查询数据时的性能消耗主要发生在磁盘IO，当查找数据时从根节点开始，将磁盘页load到内存中和查询条件比较，把满足条件的下一个磁盘页load到内存中再次比较查找，重复操作最终找到目标数据。</p><p>个人理解：树的高度越低，磁盘页load到内存的次数越少，IO少了所以性能会更高。</p><p>优化：所有的根节点作为常驻内存保存。非叶子节点也可以作为内存进行保存。</p><h4 id="为什么MySQL选择B-树而不是B-树？"><a href="#为什么MySQL选择B-树而不是B-树？" class="headerlink" title="为什么MySQL选择B+树而不是B-树？"></a>为什么MySQL选择B+树而不是B-树？</h4><p>每个节点（磁盘页）大小的选择是有讲究的，默认为16kb大小（16384b），大小可以修改但是不推荐。</p><p>数据表中每一行的数据通常不会超过1kb（按照表中几十个字段估算，没有文本格式大文件的情况），这样每个叶子节点可以保存16条数据</p><p>使用B-树时：非叶子节点同样保存data数据，<code>数据总量 = 16 ^ n </code>，其中n代表树的高度</p><p>使用B+树时：B+树的非叶子节点保存的是索引（按大点算bigint格式占8字节）和指向下一个磁盘页的指针地址（C语言实现约占6字节），这样非叶子节点可以保存的索引个数约为：<code>16384 / (8+6) = 1170</code>，三层高度的树可以保存数据总量约为：<code>1170 * 1170 * 16</code>，两千万+数据</p><p>B+树的高度是由非叶子节点存放的元素个数决定的，存放的越多树的高度越低，查询效率也就越高（load到内存的I/O次数少）。显然相同数据量的情况下，B+树的高度远远小于B-树，性能更高</p><h4 id="InnoDB索引（聚集）和MyISAM索引（非聚集）："><a href="#InnoDB索引（聚集）和MyISAM索引（非聚集）：" class="headerlink" title="InnoDB索引（聚集）和MyISAM索引（非聚集）："></a>InnoDB索引（聚集）和MyISAM索引（非聚集）：</h4><p>InnoDB存储引擎保存的索引和数据在同一个文件中 .ibd</p><p>MyISAM存储引擎保存的索引和数据在不同的文件中 .MYD 和 .MYI</p><p>注意：存储引擎描述的是数据表而不是描述数据据，最终生效的肯定是修饰数据表的存储引擎</p><p>存储引擎和磁盘保存文件格式的关系：</p><p><img src="/images/mysql/datasave.png" alt="datasave"></p><h4 id="为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？"><a href="#为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？" class="headerlink" title="为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？"></a>为什么DBA推荐创建InnoDB存储引擎的表时必须创建主键？</h4><p>开发人员在设计InnoDB表的时候，ibd文件必须要用一个B+树的数据文件来组织</p><p>表自带主键索引的情况，直接用主键索引来组织整张表的所有数据</p><p>不创建主键时，从表的第一列开始选择所有数据都不相等的列来组织B+树</p><p>如果选不到，MySQL会创建一个隐藏列来组织整张表的数据</p><p>为了减少MySQL的工作量，索引应该由我们程序员提前创建好</p><h4 id="为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？"><a href="#为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？" class="headerlink" title="为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？"></a>为什么DBA推荐创建InnoDB存储引擎的表时使用整型的自增主键？</h4><p>索引定位查找数据时，都是从根节点开始查找数据并比较</p><p>整型数字的比较速度比字符串（逐个字符比较ASCII码）比较速度快</p><p>另外整型和字符串或者uuid相比，更能节省磁盘空间（通常比较贵SSD）</p><p>索引维护到B+树中会排好序，自增每次新增都添加到树的最后，减少树的分裂和平衡</p><h4 id="InnoDb存储引擎的主键索引树和二级索引树的区别？"><a href="#InnoDb存储引擎的主键索引树和二级索引树的区别？" class="headerlink" title="InnoDb存储引擎的主键索引树和二级索引树的区别？"></a>InnoDb存储引擎的主键索引树和二级索引树的区别？</h4><p>主键索引树的叶子节点保存表中所有的数据</p><p>二级索引树的叶子节点保存组织整张表数据的聚集索引的值（通常是主键，也可能是MySQL选择的列或者隐藏列rowid）</p><p>MySQL这样设计可以减少数据的冗余节省存储空间，也保证了数据的一致性减少复杂度</p><p>二级索引查找数据时，是先找到主键索引，再通过主键索引回表到聚簇索引上面找到目标数据</p><p>二级索引其实也是稀疏的，是非聚簇索引</p><p><strong>联合索引：</strong>多个字段共同组织成一个索引</p><p>理想情况是通过1到3个联合索引把业务上80%的查询覆盖到，在加上几个单值索引覆盖剩余的业务</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YeahWorld</title>
      <link href="/posts/blog-get//"/>
      <url>/posts/blog-get//</url>
      
        <content type="html"><![CDATA[<blockquote><p>距上次写Blog 近一年，由于最近换新工作，换了工作电脑所以决定切换主题从心开始</p></blockquote><br><p>0、安装Hexo前置条件：<code>Node.js</code> 和 <code>Git</code> 安装完成</p><p>（node -v，npm -v，git –version查看是否已安装）</p><p><code>Node.js</code> 和 <code>Git</code> 没有安装的同学请自行查找安装方法，资料很多且不复杂</p><br><p>1、安装Hexo客户端命令：<code>npm install -g hexo-cli</code></p><p>问题：执行上述安装Hexo命令，窗口提示 <font color="red">idealTree:npm: sill idealTree buildDeps</font></p> <span id="more"></span> <p>解决：(产生问题的原因是，国外镜像链接失败)</p><pre class=" language-java"><code class="language-java"># 设置为国内的阿里镜像npm config set registry https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org# 检查阿里镜像是否设置成功npm config get registry# 镜像设置成功后展示如下https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span class="token operator">/</span></code></pre><p>切换镜像后，重新执行安装客户端命令，执行成功！</p><br><p>2、Hexo安装完成后执行如下命令，Hexo会在<code>&lt;folder&gt;</code>文件夹下创建所需文件：</p><pre class=" language-java"><code class="language-java">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ cd <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ npm install</code></pre><p>进入到 Hexo 安装路径，执行 <code>hexo s</code>命令，启动成功后按照提示访问<code>http://localhost:4000/</code> </p><br><p>3、Hexo常用命令（这里直接拷贝<code>helloworld</code> 中的快速开始）</p><p><strong>Create a new post</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p><strong>Run server</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><p><strong>Generate static files</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><p><strong>Deploy to remote sites</strong></p><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info:  <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><br><p>4、Hexo安装完成，首先想到的就是主题。之前使用的是<a href="https://butterfly.js.org/">butterfly</a>主题，尝试过不少美化和特效，现在换成<a href="https://github.com/iissnan/hexo-theme-next/">next</a>主题看起来更加精简，可惜了之前的全局自动播放音乐插件（花了不少时间做好的，心碎~）</p><br><p>5、主题有了，添加背景音乐（情有独钟，因为小时候觉得QQ空间的背景音乐很酷）</p><p>这里笔者使用的是<font color="red">网易云插件的外链</font>来做背景音乐，全局音乐没得问题，可惜进入Blog没有自动播放</p><p>网易云外链获取方式：登录网易云进入目标歌单（或单曲），点击分享 链接使用浏览器打开，生成外链即可</p><p>参考文章：<a href="https://blog.csdn.net/qq_39720594/article/details/105401774">Hexo + Next 主题实现全局播放背景音乐</a></p><p>文中推荐的<font color="red">使用Aplayer + MetingJS插件</font>笔者多次尝试扔没有成功（许是遗漏操作）</p><br><p>6、使用 live2 在页面右下 添加萌娘，简单有趣</p><p>a) 准备工作，执行下面命令</p><pre class=" language-java"><code class="language-java"># 安装 live2 插件npm install <span class="token operator">--</span>save hexo<span class="token operator">-</span>helper<span class="token operator">-</span>live2d# 安装人物模型 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xiazeyu<span class="token operator">/</span>live2d<span class="token operator">-</span>widget<span class="token operator">-</span>modelsnpm install live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu</code></pre><p>b) hexo 安装目录<code>_config.yml</code>配置文件添加如下：</p><pre class=" language-java"><code class="language-java">live2d<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  scriptFrom<span class="token operator">:</span> local  model<span class="token operator">:</span>     use<span class="token operator">:</span> live2d<span class="token operator">-</span>widget<span class="token operator">-</span>model<span class="token operator">-</span>koharu #模型选择  display<span class="token operator">:</span>     position<span class="token operator">:</span> right  #模型位置    width<span class="token operator">:</span> <span class="token number">150</span>       #模型宽度    height<span class="token operator">:</span> <span class="token number">300</span>      #模型高度  mobile<span class="token operator">:</span>     show<span class="token operator">:</span> <span class="token boolean">false</span>      #是否在手机端显示</code></pre><p>c) 重启验证是否生效：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p><br><p>7、参考文章：<a href="https://jlj98.top/hexo-instructions/">Hexo搭建博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 扬帆起航 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
